\documentclass{memoir}

\usepackage{./documenter}
\usepackage{./custom}

\title{
    {\HUGE JuCat.jl}\\
    {\Large }
}
\author{}

\begin{document}

\frontmatter
\maketitle
\tableofcontents

\mainmatter



\part{Home}


\hypertarget{4258390056622400630}{}


\chapter{JuCat.jl}



JuCat is a package under development with the intention to provide a framework as well a examples for computations in the realm of categories.



\hypertarget{14749083378597845891}{}


\section{Installation}



You need to have Julia installed. For reliable results Julia version at least 1.6 is required. To use JuCat do the following:




\begin{minted}{jlcon}
julia> import Pkg
julia> Pkg.add("https://github.com/FabianMaeurer/JuCat.jl")
\end{minted}



\hypertarget{18018887822361824029}{}


\section{Usage}



To use JuCat the structures from the \href{https://github.com/oscar-system/Oscar.jl}{OSCAR-System} are required. Here a minimal usage Example.




\begin{minted}{jlcon}
julia> using JuCat, Oscar;

julia> F = FiniteField(5)
Galois field with characteristic 5

julia> G = symmetric_group(2)
Sym( [ 1 .. 2 ] )

julia> X = gset(G,[1,2,3])
Oscar.GSetByElements{Oscar.PermGroup}(Sym( [ 1 .. 2 ] ), ^, [1, 2, 3], Dict{Symbol, Any}())

julia> C = ConvolutionCategory(X,F)
Convolution category over G-set with 3 elements.

julia> simples(C)
6-element Vector{ConvolutionObject{Nemo.gfp_elem, Oscar.PermGroup}}:
 Object in Convolution category over G-set with 3 elements.
 Object in Convolution category over G-set with 3 elements.
 Object in Convolution category over G-set with 3 elements.
 Object in Convolution category over G-set with 3 elements.
 Object in Convolution category over G-set with 3 elements.
 Object in Convolution category over G-set with 3 elements.

julia> groethendieck_ring(C)
ERROR: UndefVarError: groethendieck_ring not defined
\end{minted}



\hypertarget{13308868583318588695}{}


\section{Acknowledgements}



This project was started under supervision of \href{https://ulthiel.com/math/}{Prof. Ulrich Thiel}  (University of Kaiserslautern). This work is a contribution to the SFB-TRR 195 {\textquotesingle}Symbolic Tools in Mathematics and their Application{\textquotesingle} of the German Research Foundation (DFG).



\part{Exampes}


\chapter{Vector Spaces}






\hypertarget{3925623155951375781}{}


\section{Vector Space Categories}



Vector spaces in JuCat are of the abstract type




\begin{lstlisting}
abstract type VectorSpaceObject{T} <: Object end
\end{lstlisting}



All objects with vector space structure like hom-spaces are and should be implemented as a subtype of this type. They always need the following fields:




\begin{lstlisting}
basis::Vector{Any}
parent::Category
\end{lstlisting}



\hypertarget{13722891214419362258}{}


\subsection{Finite Dimensional VectorSpaces}



The simplest example to provide are the finite dimensional vector spaces over a field. This category has type




\begin{lstlisting}
VectorSpaces{T} <: TensorCategory{T}
\end{lstlisting}



and can be constructed like so:




\begin{minted}{julia}
F,a = FiniteField(5,2)
Vec = VectorSpaces(F)
\end{minted}


\begin{lstlisting}
Category of finite dimensional VectorSpaces over Finite field of degree 2 over F_5
\end{lstlisting}



Objects of this category are of the type




\begin{lstlisting}
VSObject{T} <: VectorSpaceObject{T}
\end{lstlisting}



Every vector space object is defined by a basis and a base field provided by the parent category.


\hypertarget{9222576805308484798}{} 
\hyperlink{9222576805308484798}{\texttt{JuCat.VectorSpaceObject}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
VectorSpaceObject{T}
\end{minted}

An object in the category of finite dimensional vector spaces.



\href{https://github.com/FabianMaeurer/JuCat.jl/blob/367390e2d003deec2ababa73caeab405e934bb35/src/structures/abstracts.jl#L21-L25}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3146134203222481508}{} 
\hyperlink{3146134203222481508}{\texttt{JuCat.VectorSpaceObject}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
VectorSpaceObject(Vec::VectorSpaces, n::Int64)
VectorSpaceObject(K::Field, n::Int)
VectorSpaceObject(Vec::VectorSpaces, basis::Vector)
VectorSpaceObject(K::Field, basis::Vector)
\end{minted}

The n-dimensional vector space with basis v1,..,vn (or other specified basis)



\href{https://github.com/FabianMaeurer/JuCat.jl/blob/367390e2d003deec2ababa73caeab405e934bb35/src/structures/VectorSpaces/VectorSpaces.jl#L39-L46}{\texttt{source}}


\end{adjustwidth}

Morphisms in this Category are defined only by matrices of matching dimensions. They are typed as




\begin{minted}{julia}
VSMorphism{T} <: Morphism
\end{minted}



and constructed giving a domain, codomain and matrix element.


\hypertarget{16637970097491642119}{} 
\hyperlink{16637970097491642119}{\texttt{JuCat.Morphism}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Morphism(X::VectorSpaceObject, Y::VectorSpaceObject, m::MatElem)
\end{minted}

Return a morphism in the category of vector spaces defined by m.



\href{https://github.com/FabianMaeurer/JuCat.jl/blob/367390e2d003deec2ababa73caeab405e934bb35/src/structures/VectorSpaces/VectorSpaces.jl#L66-L70}{\texttt{source}}


\end{adjustwidth}

\hypertarget{1363918412184924542}{}


\subsection{Graded Vector Spaces}



Very similar we have the category of finite dimensional (twisted) \(G\)-graded vector spaces for a finite group \(G\). We have the type




\begin{lstlisting}
GradedVectorSpaces{T,G} <: VectorSpaces{T,G}
\end{lstlisting}



and they are constructed in straightforward manner




\begin{minted}{julia}
G = symmetric_group(6)
F,a = FiniteField(2,3)
VecG = GradedVectorSpaces(F,G)
\end{minted}


\begin{lstlisting}
Category of finite dimensional graded vector spaces over Finite field of degree 3 over F_2
with simple objects in Sym( [ 1 .. 6 ] ).
\end{lstlisting}



To add a nontrivial associator (twist) construct a Cocycle\{3\} object coding a 3-cocycle of the group \(G\). By now no checking of this condition happens.




\begin{lstlisting}
C = #TODO CoCycle(G, )
VecG = #VectorSpaces(G,QQ,C)
\end{lstlisting}



Graded vector spaces decompose into direct sums of vector spaces for each element in \(G\).




\begin{lstlisting}
GVSObject{T,G} <: VectorSpaceObject{T}
\end{lstlisting}




\begin{minted}{julia}
G = symmetric_group(5)
g,s = gens(G)
V1 = VectorSpaceObject(QQ,5)
V2 = VectorSpaceObject(QQ, [:v, :w])
W = VectorSpaceObject(g => V1, s => V2, g*s => V1⊗V2)
\end{minted}


\begin{lstlisting}
Graded Vector Space of dimension 17 over Rational Field. Direct sum of 
   (1,2,3,4,5) ⋅ Vector space of dimension 5 over Rational Field.
   (1,2) ⋅ Vector space of dimension 2 over Rational Field.
   (2,3,4,5) ⋅ Vector space of dimension 10 over Rational Field.

\end{lstlisting}



Morphisms are implemented analogously by pairs of group elements and vectorspace objects.




\begin{lstlisting}
GVSMorphism{T,G} <: Morphism
\end{lstlisting}



The constructors are


\hypertarget{17488230208688022226}{} 
\hyperlink{17488230208688022226}{\texttt{JuCat.Morphism}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Morphism(D::GVSObject, C::GVSObject, m::Dict)
\end{minted}

Morphism between graded vector spaces defined by pairs of elements and morphisms g => (Dg -> Cg).



\href{https://github.com/FabianMaeurer/JuCat.jl/blob/367390e2d003deec2ababa73caeab405e934bb35/src/structures/VectorSpaces/GradedVectorSpaces.jl#L48-L53}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7177969606607283338}{} 
\hyperlink{7177969606607283338}{\texttt{JuCat.Morphism}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Morphism(D::GVSObject, C::GVSObject, m::Pair...)
\end{minted}

Morphism between graded vector spaces defined by pairs of elements and morphisms g => (Dg -> Cg).



\href{https://github.com/FabianMaeurer/JuCat.jl/blob/367390e2d003deec2ababa73caeab405e934bb35/src/structures/VectorSpaces/GradedVectorSpaces.jl#L65-L70}{\texttt{source}}


\end{adjustwidth}

\hypertarget{13716495418266911399}{}


\subsection{Functionality}



(Graded) vector spaces form a semisimple tensor category. Thus the methods for direct sums, standard tensor products, one and zero object are all implemented.


\hypertarget{3005374513504276669}{} 
\hyperlink{3005374513504276669}{\texttt{AbstractAlgebra.Generic.dim}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
dim(V::VectorSpaceObject) = length(V.basis)
\end{minted}

Return the vector space dimension of \(V\).



\href{https://github.com/FabianMaeurer/JuCat.jl/blob/367390e2d003deec2ababa73caeab405e934bb35/src/structures/VectorSpaces/VectorSpaces.jl#L127-L131}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18052978176005545894}{} 
\hyperlink{18052978176005545894}{\texttt{AbstractAlgebra.isisomorphic}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
isisomorphic(V::VSObject, W::VSObject)
\end{minted}

Check whether \(V\) and \(W\)are isomorphic. Return the isomorphisms if existent.



\href{https://github.com/FabianMaeurer/JuCat.jl/blob/367390e2d003deec2ababa73caeab405e934bb35/src/structures/VectorSpaces/VectorSpaces.jl#L162-L166}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15750710740055264726}{} 
\hyperlink{15750710740055264726}{\texttt{Base.one}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
one(Vec::VectorSpaces) = VectorSpaceObject(base_ring(Vec),1)
\end{minted}

Return the one-dimensional vector space.



\href{https://github.com/FabianMaeurer/JuCat.jl/blob/367390e2d003deec2ababa73caeab405e934bb35/src/structures/VectorSpaces/VectorSpaces.jl#L141-L145}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2429087325790184140}{} 
\hyperlink{2429087325790184140}{\texttt{Base.zero}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
zero(Vec::VectorSpaces) = VectorSpaceObject(base_ring(Vec), 0)
\end{minted}

Return the zero-dimensional vector space.



\href{https://github.com/FabianMaeurer/JuCat.jl/blob/367390e2d003deec2ababa73caeab405e934bb35/src/structures/VectorSpaces/VectorSpaces.jl#L148-L152}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3782291054861654459}{} 
\hyperlink{3782291054861654459}{\texttt{Hecke.id}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
id(X::VectorSpaceObject{T}) where T
\end{minted}

Return the identity on the vector space \(X\).



\href{https://github.com/FabianMaeurer/JuCat.jl/blob/367390e2d003deec2ababa73caeab405e934bb35/src/structures/VectorSpaces/VectorSpaces.jl#L298-L302}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9611467537333931590}{} 
\hyperlink{9611467537333931590}{\texttt{Hecke.tensor\_product}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
tensor_product(X::VectorSpaceObject{T}, Y::VectorSpaceObject{T}) where {T,S1,S2}
\end{minted}

Return the tensor product of vector spaces.



\href{https://github.com/FabianMaeurer/JuCat.jl/blob/367390e2d003deec2ababa73caeab405e934bb35/src/structures/VectorSpaces/VectorSpaces.jl#L247-L251}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3913359957533821152}{} 
\hyperlink{3913359957533821152}{\texttt{Hecke.tensor\_product}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
tensor_product(f::VectorSpaceMorphism, g::VectorSpaceMorphism) where {T}
\end{minted}

Return the tensor product of vector space morphisms.



\href{https://github.com/FabianMaeurer/JuCat.jl/blob/367390e2d003deec2ababa73caeab405e934bb35/src/structures/VectorSpaces/VectorSpaces.jl#L260-L264}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17722560261235752128}{} 
\hyperlink{17722560261235752128}{\texttt{JuCat.Hom}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Hom(X::VectorSpaceObject{T}, Y::VectorSpaceObject{T}) where T
\end{minted}

Return the Hom(\(X,Y\)`) as a vector space.



\href{https://github.com/FabianMaeurer/JuCat.jl/blob/367390e2d003deec2ababa73caeab405e934bb35/src/structures/VectorSpaces/VectorSpaces.jl#L346-L350}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10556131517828134115}{} 
\hyperlink{10556131517828134115}{\texttt{JuCat.associator}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
associator(X::VectorSpaceObject{T}, Y::VectorSpaceObject{T}, Z::VectorSpaceObject{T}) where T
\end{minted}

Return the associator isomorphism a::(X⊗Y)⊗Z -> X⊗(Y⊗Z).



\href{https://github.com/FabianMaeurer/JuCat.jl/blob/367390e2d003deec2ababa73caeab405e934bb35/src/structures/VectorSpaces/VectorSpaces.jl#L319-L323}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9937505529784759153}{} 
\hyperlink{9937505529784759153}{\texttt{JuCat.dsum}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
dsum(f::VectorSpaceMorphism{T},g::VectorSpaceMorphism{T}) where T
\end{minted}

Return the direct sum of morphisms of vector spaces.



\href{https://github.com/FabianMaeurer/JuCat.jl/blob/367390e2d003deec2ababa73caeab405e934bb35/src/structures/VectorSpaces/VectorSpaces.jl#L227-L231}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1177256512019415858}{} 
\hyperlink{1177256512019415858}{\texttt{JuCat.dsum}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
dsum(X::VectorSpaceObject{T}, Y::VectorSpaceObject{T}, morphisms = false) where {T}
\end{minted}

Direct sum of vector spaces together with the embedding morphisms if morphisms = true.



\href{https://github.com/FabianMaeurer/JuCat.jl/blob/367390e2d003deec2ababa73caeab405e934bb35/src/structures/VectorSpaces/VectorSpaces.jl#L195-L199}{\texttt{source}}


\end{adjustwidth}

\chapter{Representations}




\hypertarget{5231629623898793339}{}


\section{Representations}



We provide a simple abstract type hirarchy for representation categories:




\begin{lstlisting}
abstract type RepresentationCategory{T} <: TensorCategory{T}
\end{lstlisting}



A representation category always requires the field




\begin{lstlisting}
base_ring::Field
\end{lstlisting}



\hypertarget{9324066174772501507}{}


\subsection{Representations of Finite groups}



Let \(G\) be a finite group. We consider the category of finite dimensinal \(k\)-representations of \(G\).




\begin{lstlisting}
GroupRepresentationCategory{T,G} <: RepresentationCategory{T}
\end{lstlisting}



Build it with the constructor


\hypertarget{9169222131237923867}{} 
\hyperlink{9169222131237923867}{\texttt{JuCat.RepresentationCategory}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
RepresentationCategory(G::GAPGroup, F::Field)
\end{minted}

Category of finite dimensonal group representations of {\textbackslash}G.



\href{https://github.com/FabianMaeurer/JuCat.jl/blob/367390e2d003deec2ababa73caeab405e934bb35/src/structures/Representations/GroupRepresentations.jl#L22-L26}{\texttt{source}}


\end{adjustwidth}

A group representation is defined by a group homomorphism from \(G\) into a finite dimensional vector space \(k^n\). These objects are of type




\begin{lstlisting}
GroupRepresentation{T,G} <: Representation
\end{lstlisting}



They are constructed in one of two ways, either by images of generators or by a function


\hypertarget{12571968626116161650}{} 
\hyperlink{12571968626116161650}{\texttt{JuCat.Representation}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Representation(G::GAPGroup, pre_img::Vector, img::Vector)
\end{minted}

Group representation defined by the images of generators of G.



\href{https://github.com/FabianMaeurer/JuCat.jl/blob/367390e2d003deec2ababa73caeab405e934bb35/src/structures/Representations/GroupRepresentations.jl#L35-L39}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11844280100991716802}{} 
\hyperlink{11844280100991716802}{\texttt{JuCat.Representation}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Representation(G::GAPGroup, m::Function)
\end{minted}

Group representation defined by m:G -> Mat\_n.



\href{https://github.com/FabianMaeurer/JuCat.jl/blob/367390e2d003deec2ababa73caeab405e934bb35/src/structures/Representations/GroupRepresentations.jl#L49-L53}{\texttt{source}}


\end{adjustwidth}

where in both cases the images are required to be fitting MatrixElem objects.



Since group reprsentation categories are tensor categories, we again have methods for the important operations


\hypertarget{17107855014913617445}{} 
\hyperlink{17107855014913617445}{\texttt{JuCat.Morphism}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Morphism(ρ::GroupRepresentation{T,G}, τ::GroupRepresentation{T,G}, m::MatElem{T}; check = true) where {T,G}
\end{minted}

Morphism between representations defined by \(m\). If check == false equivariancy will not be checked.



\href{https://github.com/FabianMaeurer/JuCat.jl/blob/367390e2d003deec2ababa73caeab405e934bb35/src/structures/Representations/GroupRepresentations.jl#L63-L68}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7064680413999145372}{} 
\hyperlink{7064680413999145372}{\texttt{AbstractAlgebra.isisomorphic}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
isisomorphic(σ::GroupRepresentation{T,G}, τ::GroupRepresentation{T,G}) where {T,G}
\end{minted}

Check whether σ and τ are isomorphic. If true return the isomorphism.



\href{https://github.com/FabianMaeurer/JuCat.jl/blob/367390e2d003deec2ababa73caeab405e934bb35/src/structures/Representations/GroupRepresentations.jl#L161-L165}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4849929255757053512}{} 
\hyperlink{4849929255757053512}{\texttt{Base.one}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
one(Rep::GroupRepresentationCategory{T,G}) where {T,G}
\end{minted}

Return the trivial representation.



\href{https://github.com/FabianMaeurer/JuCat.jl/blob/367390e2d003deec2ababa73caeab405e934bb35/src/structures/Representations/GroupRepresentations.jl#L120-L124}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1444146782523177002}{} 
\hyperlink{1444146782523177002}{\texttt{Base.parent}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
parent(ρ::GroupRepresentation{T,G}) where {T,G}
\end{minted}

Return the parent representation category of ρ.



\href{https://github.com/FabianMaeurer/JuCat.jl/blob/367390e2d003deec2ababa73caeab405e934bb35/src/structures/Representations/GroupRepresentations.jl#L102-L106}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12739541320780261150}{} 
\hyperlink{12739541320780261150}{\texttt{Base.zero}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
zero(Rep::GroupRepresentationCategory{T,G}) where {T,G}
\end{minted}

Return the zero reprensentation.



\href{https://github.com/FabianMaeurer/JuCat.jl/blob/367390e2d003deec2ababa73caeab405e934bb35/src/structures/Representations/GroupRepresentations.jl#L109-L113}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12309669422231862422}{} 
\hyperlink{12309669422231862422}{\texttt{Hecke.decompose}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
decompose(σ::GroupRepresentation)
\end{minted}

Decompose the representation into a direct sum of simple objects. Return a list of tuples with simple objects and multiplicities.



\href{https://github.com/FabianMaeurer/JuCat.jl/blob/367390e2d003deec2ababa73caeab405e934bb35/src/structures/Representations/GroupRepresentations.jl#L407-L412}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13339681357403674067}{} 
\hyperlink{13339681357403674067}{\texttt{Hecke.id}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
id(ρ::GroupRepresentation{T,G}) where {T,G}
\end{minted}

Return the identity on ρ.



\href{https://github.com/FabianMaeurer/JuCat.jl/blob/367390e2d003deec2ababa73caeab405e934bb35/src/structures/Representations/GroupRepresentations.jl#L132-L136}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4189856604944326616}{} 
\hyperlink{4189856604944326616}{\texttt{Hecke.tensor\_product}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
tensor_product(f::GroupRepresentationMorphism, g::GroupRepresentationMorphism)
\end{minted}

Return the tensor product of morphisms of representations.



\href{https://github.com/FabianMaeurer/JuCat.jl/blob/367390e2d003deec2ababa73caeab405e934bb35/src/structures/Representations/GroupRepresentations.jl#L282-L286}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13441408242965868047}{} 
\hyperlink{13441408242965868047}{\texttt{Hecke.tensor\_product}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
tensor_product(ρ::GroupRepresentation{T}, τ::GroupRepresentation{T}) where T
\end{minted}

Return the tensor product of representations.



\href{https://github.com/FabianMaeurer/JuCat.jl/blob/367390e2d003deec2ababa73caeab405e934bb35/src/structures/Representations/GroupRepresentations.jl#L262-L266}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9706262962411317485}{} 
\hyperlink{9706262962411317485}{\texttt{JuCat.Hom}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Hom(σ::GroupRepresentation{T,G}, τ::GroupRepresentation{T,G}) where {T,G}
\end{minted}

Return the hom-space of the representations as a vector space.



\href{https://github.com/FabianMaeurer/JuCat.jl/blob/367390e2d003deec2ababa73caeab405e934bb35/src/structures/Representations/GroupRepresentations.jl#L442-L446}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11633833845246005104}{} 
\hyperlink{11633833845246005104}{\texttt{JuCat.dsum}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
dsum(f::GroupRepresentationMorphism, g::GroupRepresentationMorphism)
\end{minted}

Direct sum of morphisms of representations.



\href{https://github.com/FabianMaeurer/JuCat.jl/blob/367390e2d003deec2ababa73caeab405e934bb35/src/structures/Representations/GroupRepresentations.jl#L351-L355}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13403022418623350768}{} 
\hyperlink{13403022418623350768}{\texttt{JuCat.dsum}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
dsum(ρ::GroupRepresentation{T,G}, τ::GroupRepresentation{T,G}, morphisms::Bool = false) where {T,G}
\end{minted}

Return the direct sum of representations. If morphisms is set true inclusion and projection morphisms are also returned.



\href{https://github.com/FabianMaeurer/JuCat.jl/blob/367390e2d003deec2ababa73caeab405e934bb35/src/structures/Representations/GroupRepresentations.jl#L312-L317}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17037802207135643902}{} 
\hyperlink{17037802207135643902}{\texttt{JuCat.simples}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
simples(Rep::GroupRepresentationCategory{T,G}) where {T,G}
\end{minted}

Return a list of the simple objects in Rep.



\href{https://github.com/FabianMaeurer/JuCat.jl/blob/367390e2d003deec2ababa73caeab405e934bb35/src/structures/Representations/GroupRepresentations.jl#L378-L382}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4399047499095318369}{} 
\hyperlink{4399047499095318369}{\texttt{Oscar.issemisimple}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
issemisimple(C::GroupRepresentationCategory)
\end{minted}

Return true if C is semisimple else false.



\href{https://github.com/FabianMaeurer/JuCat.jl/blob/367390e2d003deec2ababa73caeab405e934bb35/src/structures/Representations/GroupRepresentations.jl#L80-L84}{\texttt{source}}


\end{adjustwidth}

\chapter{Coherent Sheaves}




\hypertarget{5947772561377446122}{}


\section{Coherent sheaves on Finite Sets}



Coherent sheaves on a finite set \(X\) are characterised by the stalks of the the elements \(x \in X\). I.e. a coherent sheaf on \(X\) is a collection of vector spaces \(V_x\) for each \(x\in X\). More generally for a group \(G\) and a G-set \(X\) we can define consider \(G\)-equivariant sheaves on \(X\). In this case a sheaf is specified by representations of the stabilizers of representatives for the orbits.



\hypertarget{17053673031877315927}{}


\subsection{Equivariant Coherent Sheaves}



We provide the datatype




\begin{lstlisting}
CoherentSheaf{T,G} <: Object
\end{lstlisting}



The category of equivariant coherent sheafes has type




\begin{lstlisting}
CohSheaves{T,G} <: MultiTensorCategory{T}
\end{lstlisting}



and can be constructed via


\hypertarget{72414698628682391}{} 
\hyperlink{72414698628682391}{\texttt{JuCat.CohSheaves}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
CohSheaves(X::GSet,F::Field)
\end{minted}

The category of \(G\)-equivariant coherent sheafes on \(X\).



\href{https://github.com/FabianMaeurer/JuCat.jl/blob/367390e2d003deec2ababa73caeab405e934bb35/src/structures/ConvolutionCategory/CoherentSheaves.jl#L23-L27}{\texttt{source}}



\begin{minted}{julia}
CohSheaves(X, F::Field)
\end{minted}

The category of coherent sheafes on \(X\).



\href{https://github.com/FabianMaeurer/JuCat.jl/blob/367390e2d003deec2ababa73caeab405e934bb35/src/structures/ConvolutionCategory/CoherentSheaves.jl#L35-L39}{\texttt{source}}


\end{adjustwidth}

Morphisms are given by morphisms of representations of the stalks and are of type




\begin{lstlisting}
CohSheafMorphism{T,G} <: Morphism
\end{lstlisting}


\hypertarget{5299226145830094980}{} 
\hyperlink{5299226145830094980}{\texttt{JuCat.CohSheaves}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
CohSheaves(X, F::Field)
\end{minted}

The category of coherent sheafes on \(X\).



\href{https://github.com/FabianMaeurer/JuCat.jl/blob/367390e2d003deec2ababa73caeab405e934bb35/src/structures/ConvolutionCategory/CoherentSheaves.jl#L35-L39}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12460639737943450204}{} 
\hyperlink{12460639737943450204}{\texttt{JuCat.CohSheaves}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
CohSheaves(X::GSet,F::Field)
\end{minted}

The category of \(G\)-equivariant coherent sheafes on \(X\).



\href{https://github.com/FabianMaeurer/JuCat.jl/blob/367390e2d003deec2ababa73caeab405e934bb35/src/structures/ConvolutionCategory/CoherentSheaves.jl#L23-L27}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8327360857040738072}{} 
\hyperlink{8327360857040738072}{\texttt{AbstractAlgebra.isisomorphic}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
isisomorphic(X::CohSheaf{T,G}, Y::CohSheaf{T,G}) where {T,G}
\end{minted}

Check whether \(X\)and \(Y\) are isomorphic and the isomorphism if possible.



\href{https://github.com/FabianMaeurer/JuCat.jl/blob/367390e2d003deec2ababa73caeab405e934bb35/src/structures/ConvolutionCategory/CoherentSheaves.jl#L94-L98}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10859713285095806556}{} 
\hyperlink{10859713285095806556}{\texttt{Base.one}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
one(C::CohSheaves{T,G}) where {T,G}
\end{minted}

Return the one object in \(C\).



\href{https://github.com/FabianMaeurer/JuCat.jl/blob/367390e2d003deec2ababa73caeab405e934bb35/src/structures/ConvolutionCategory/CoherentSheaves.jl#L196-L200}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9779985997723116531}{} 
\hyperlink{9779985997723116531}{\texttt{Base.zero}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
zero(C::CohSheaves)
\end{minted}

Return the zero sheaf on the \(G\)-set.



\href{https://github.com/FabianMaeurer/JuCat.jl/blob/367390e2d003deec2ababa73caeab405e934bb35/src/structures/ConvolutionCategory/CoherentSheaves.jl#L77-L81}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4292008897843854263}{} 
\hyperlink{4292008897843854263}{\texttt{Hecke.decompose}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
decompose(X::CohSheaf)
\end{minted}

Decompose \(X\) into a direct sum of simple objects with multiplicity.



\href{https://github.com/FabianMaeurer/JuCat.jl/blob/367390e2d003deec2ababa73caeab405e934bb35/src/structures/ConvolutionCategory/CoherentSheaves.jl#L250-L254}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6020448135502085852}{} 
\hyperlink{6020448135502085852}{\texttt{Hecke.tensor\_product}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
tensor_product(f::CohSheafMorphism{T,G}, g::CohSheafMorphism{T,G}) where {T,G}
\end{minted}

Return the tensor product of morphisms of equivariant coherent sheaves.



\href{https://github.com/FabianMaeurer/JuCat.jl/blob/367390e2d003deec2ababa73caeab405e934bb35/src/structures/ConvolutionCategory/CoherentSheaves.jl#L183-L187}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18361793401985725179}{} 
\hyperlink{18361793401985725179}{\texttt{Hecke.tensor\_product}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
tensor_product(X::CohSheaf{T,G}, Y::CohSheaf{T,G}) where {T,G}
\end{minted}

Return the tensor product of equivariant coherent sheaves.



\href{https://github.com/FabianMaeurer/JuCat.jl/blob/367390e2d003deec2ababa73caeab405e934bb35/src/structures/ConvolutionCategory/CoherentSheaves.jl#L173-L177}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6888745570346083153}{} 
\hyperlink{6888745570346083153}{\texttt{JuCat.Hom}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Hom(X::CohSheaf{T,G}, Y::CohSheaf{T,G}) where {T,G}
\end{minted}

Return Hom(\(X,Y\)) as a vector space.



\href{https://github.com/FabianMaeurer/JuCat.jl/blob/367390e2d003deec2ababa73caeab405e934bb35/src/structures/ConvolutionCategory/CoherentSheaves.jl#L278-L282}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13720751386988287155}{} 
\hyperlink{13720751386988287155}{\texttt{JuCat.dsum}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
dsum(f::CohSheafMorphism{T,G}, g::CohSheafMorphism{T,G}) where {T,G}
\end{minted}

Return the direct sum of morphisms of sheaves.



\href{https://github.com/FabianMaeurer/JuCat.jl/blob/367390e2d003deec2ababa73caeab405e934bb35/src/structures/ConvolutionCategory/CoherentSheaves.jl#L154-L158}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8802874031542181034}{} 
\hyperlink{8802874031542181034}{\texttt{JuCat.dsum}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
dsum(X::CohSheaf{T,G}, Y::CohSheaf{T,G}, morphisms::Bool = false) where {T,G}
\end{minted}

Return the direct sum of sheaves. Return also the inclusion and projection if morphisms = true.



\href{https://github.com/FabianMaeurer/JuCat.jl/blob/367390e2d003deec2ababa73caeab405e934bb35/src/structures/ConvolutionCategory/CoherentSheaves.jl#L137-L142}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8170827327284328945}{} 
\hyperlink{8170827327284328945}{\texttt{JuCat.simples}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
simples(C::CohSheaves{T,G}) where {T,G}
\end{minted}

Return the simple objects of \(C\).



\href{https://github.com/FabianMaeurer/JuCat.jl/blob/367390e2d003deec2ababa73caeab405e934bb35/src/structures/ConvolutionCategory/CoherentSheaves.jl#L224-L228}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11851872779302020562}{} 
\hyperlink{11851872779302020562}{\texttt{JuCat.stalks}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
stalks(X::CohSheaf)
\end{minted}

Return the stalks of \(X\).



\href{https://github.com/FabianMaeurer/JuCat.jl/blob/367390e2d003deec2ababa73caeab405e934bb35/src/structures/ConvolutionCategory/CoherentSheaves.jl#L58-L62}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5441322352205534514}{} 
\hyperlink{5441322352205534514}{\texttt{Oscar.issemisimple}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
issemisimple(C::CohSheaves)
\end{minted}

Return whether \(C\)is semisimple.



\href{https://github.com/FabianMaeurer/JuCat.jl/blob/367390e2d003deec2ababa73caeab405e934bb35/src/structures/ConvolutionCategory/CoherentSheaves.jl#L51-L55}{\texttt{source}}


\end{adjustwidth}

\hypertarget{16097779932059729431}{}


\subsection{Convolution Category}



The objects of this category are again \(G\)-equivariant coherent sheaves on a finite \(G\)-set \(X\times X\). But we endow them with a different monoidal product.



Let \(p_{ij}: X\times X\times X \to X \times X\) be the canonical projections. Then we define the monoidal product of two coherent sheaves \(x\) and \(y\)



\begin{equation*}
\begin{split}\begin{aligned}
x\otimes y = p_{13}_\ast(p_{12}^\ast(x)\otimes' p_{23}^\ast(y))
\end{aligned}\end{split}\end{equation*}


where \(\otimes'\)is the monoidal product of \(Coh(X\times X\times X)\). Similar for morphisms.



Objects in this category are of type




\begin{lstlisting}
ConvolutionObject{T,G} <: Object
\end{lstlisting}



while the convolution category is of type




\begin{lstlisting}
ConvolutionCategory{T,G} <: MultiTensorCategory{T}
\end{lstlisting}



and can be constructed by


\hypertarget{6882204948059180058}{} 
\hyperlink{6882204948059180058}{\texttt{JuCat.ConvolutionCategory}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
ConvolutionCategory(X::GSet, K::Field)
\end{minted}

Return the category of equivariant coherent sheaves on \(X\) with convolution product.



\href{https://github.com/FabianMaeurer/JuCat.jl/blob/367390e2d003deec2ababa73caeab405e934bb35/src/structures/ConvolutionCategory/ConvolutionCategory.jl#L23-L27}{\texttt{source}}



\begin{minted}{julia}
ConvolutionCategory(X, K::Field)
\end{minted}

Return the category of coherent sheaves on \(X\) with convolution product.



\href{https://github.com/FabianMaeurer/JuCat.jl/blob/367390e2d003deec2ababa73caeab405e934bb35/src/structures/ConvolutionCategory/ConvolutionCategory.jl#L45-L49}{\texttt{source}}


\end{adjustwidth}

Morphisms are just morphisms of coherent sheaves with the new tensor product.




\begin{lstlisting}
ConvolutionMorphism{T,G} <: Morphism
\end{lstlisting}


\hypertarget{11439898130865602624}{} 
\hyperlink{11439898130865602624}{\texttt{JuCat.ConvolutionCategory}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
ConvolutionCategory(X, K::Field)
\end{minted}

Return the category of coherent sheaves on \(X\) with convolution product.



\href{https://github.com/FabianMaeurer/JuCat.jl/blob/367390e2d003deec2ababa73caeab405e934bb35/src/structures/ConvolutionCategory/ConvolutionCategory.jl#L45-L49}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13116209171061471445}{} 
\hyperlink{13116209171061471445}{\texttt{JuCat.ConvolutionCategory}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
ConvolutionCategory(X::GSet, K::Field)
\end{minted}

Return the category of equivariant coherent sheaves on \(X\) with convolution product.



\href{https://github.com/FabianMaeurer/JuCat.jl/blob/367390e2d003deec2ababa73caeab405e934bb35/src/structures/ConvolutionCategory/ConvolutionCategory.jl#L23-L27}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15935237061258954038}{} 
\hyperlink{15935237061258954038}{\texttt{AbstractAlgebra.isisomorphic}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
isisomorphic(X::ConvolutionObject{T,G}, Y::ConvolutionObject{T,G})
\end{minted}

Check whether \(X\)and \(Y\)are isomorphic. Return the isomorphism if true.



\href{https://github.com/FabianMaeurer/JuCat.jl/blob/367390e2d003deec2ababa73caeab405e934bb35/src/structures/ConvolutionCategory/ConvolutionCategory.jl#L85-L89}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11329682958942309008}{} 
\hyperlink{11329682958942309008}{\texttt{Base.one}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
one(C::ConvolutionCategory{T,G}) where {T,G}
\end{minted}

Return the one object in Conv(\(X\)).



\href{https://github.com/FabianMaeurer/JuCat.jl/blob/367390e2d003deec2ababa73caeab405e934bb35/src/structures/ConvolutionCategory/ConvolutionCategory.jl#L176-L180}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10692409214207844851}{} 
\hyperlink{10692409214207844851}{\texttt{Base.zero}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
zero(C::ConvolutionCategory{T,G}) where {T,G}
\end{minted}

Return the zero object in Conv(\(X\)).



\href{https://github.com/FabianMaeurer/JuCat.jl/blob/367390e2d003deec2ababa73caeab405e934bb35/src/structures/ConvolutionCategory/ConvolutionCategory.jl#L140-L144}{\texttt{source}}


\end{adjustwidth}
\hypertarget{924957353456778592}{} 
\hyperlink{924957353456778592}{\texttt{Hecke.decompose}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
decompose(X::ConvolutionObject)
\end{minted}

Decompose \(X\) into a direct sum of simple objects with multiplicities.



\href{https://github.com/FabianMaeurer/JuCat.jl/blob/367390e2d003deec2ababa73caeab405e934bb35/src/structures/ConvolutionCategory/ConvolutionCategory.jl#L218-L222}{\texttt{source}}


\end{adjustwidth}
\hypertarget{426415593810322569}{} 
\hyperlink{426415593810322569}{\texttt{Hecke.tensor\_product}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
tensor_product(f::ConvolutionMorphism{T,G}, g::ConvolutionMorphism{T,G}) where {T,G}
\end{minted}

Return the convolution product of morphisms of coherent sheaves.



\href{https://github.com/FabianMaeurer/JuCat.jl/blob/367390e2d003deec2ababa73caeab405e934bb35/src/structures/ConvolutionCategory/ConvolutionCategory.jl#L163-L167}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16297541892943593034}{} 
\hyperlink{16297541892943593034}{\texttt{Hecke.tensor\_product}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
tensor_product(X::ConvolutionObject{T,G}, Y::ConvolutionObject{T,G}) where {T,G}
\end{minted}

Return the convolution product of coherent sheaves.



\href{https://github.com/FabianMaeurer/JuCat.jl/blob/367390e2d003deec2ababa73caeab405e934bb35/src/structures/ConvolutionCategory/ConvolutionCategory.jl#L151-L155}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2205927259978641805}{} 
\hyperlink{2205927259978641805}{\texttt{JuCat.Hom}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
Hom(X::ConvolutionObject{T,G}, Y::ConvolutionObject{T,G}) where {T,G}
\end{minted}

Return Hom(\(X,Y\)) as a vector space.



\href{https://github.com/FabianMaeurer/JuCat.jl/blob/367390e2d003deec2ababa73caeab405e934bb35/src/structures/ConvolutionCategory/ConvolutionCategory.jl#L239-L243}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15703756832181133610}{} 
\hyperlink{15703756832181133610}{\texttt{JuCat.dsum}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
dsum(f::ConvolutionMorphism{T,G}, g::ConvolutionMorphism{T,G}) where {T,G}
\end{minted}

Return the direct sum of morphisms of coherent sheaves (with convolution product).



\href{https://github.com/FabianMaeurer/JuCat.jl/blob/367390e2d003deec2ababa73caeab405e934bb35/src/structures/ConvolutionCategory/ConvolutionCategory.jl#L125-L129}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4092292824888948722}{} 
\hyperlink{4092292824888948722}{\texttt{JuCat.dsum}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
dsum(X::ConvolutionObject{T,G}, Y::ConvolutionObject{T,G}, morphisms::Bool = false) where {T,G}
\end{minted}

documentation



\href{https://github.com/FabianMaeurer/JuCat.jl/blob/367390e2d003deec2ababa73caeab405e934bb35/src/structures/ConvolutionCategory/ConvolutionCategory.jl#L108-L112}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14631726498957465616}{} 
\hyperlink{14631726498957465616}{\texttt{JuCat.orbit\_stabilizers}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
orbit_stabilizers(C::ConvolutionCategory)
\end{minted}

Return the stabilizers of representatives of the orbits.



\href{https://github.com/FabianMaeurer/JuCat.jl/blob/367390e2d003deec2ababa73caeab405e934bb35/src/structures/ConvolutionCategory/ConvolutionCategory.jl#L65-L69}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8694340320441112263}{} 
\hyperlink{8694340320441112263}{\texttt{JuCat.simples}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
simples(C::ConvolutionCategory{T,G}) where {T,G}
\end{minted}

Return a list of simple objects in Conv(\(X\)).



\href{https://github.com/FabianMaeurer/JuCat.jl/blob/367390e2d003deec2ababa73caeab405e934bb35/src/structures/ConvolutionCategory/ConvolutionCategory.jl#L209-L213}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16172694927088392840}{} 
\hyperlink{16172694927088392840}{\texttt{JuCat.stalks}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
stalks(X::ConvolutionObject)
\end{minted}

Return the stalks of the sheaf \(X\).



\href{https://github.com/FabianMaeurer/JuCat.jl/blob/367390e2d003deec2ababa73caeab405e934bb35/src/structures/ConvolutionCategory/ConvolutionCategory.jl#L74-L78}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11339324696069303458}{} 
\hyperlink{11339324696069303458}{\texttt{Oscar.issemisimple}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{minted}{julia}
issemisimple(C::ConvolutionCategory)
\end{minted}

Check whether \(C\) semisimple.



\href{https://github.com/FabianMaeurer/JuCat.jl/blob/367390e2d003deec2ababa73caeab405e934bb35/src/structures/ConvolutionCategory/ConvolutionCategory.jl#L58-L62}{\texttt{source}}


\end{adjustwidth}

\part{Multitensor Categories}


\hypertarget{3429443789683603020}{}


\chapter{Multitensor Categories}



The main idea of JuCat is to provide abstract methods for categorical computations. The abstract types \texttt{MultiTensorCategory} and \texttt{TensorCategory} are intended for this purpose. To use these abstract methods you need to provide some functionality for your categories.



\hypertarget{16292526960150728896}{}


\chapter{Necessities}



For minimal function of \texttt{YourCategory <: MultiTensorCategory} together with Objects \texttt{YourObject <: Object} and morphisms \texttt{YourMorphism <: Morphism} you have to minimally build




\begin{minted}{julia}
struct YourCategory <: MultiTensorCategory
  base_ring::Field
end

struct YourObject <: Object
  parent::YourCategory
end

struct YourMorphism <: Morphism
  domain::YourObject
  codomain::YourObject
end
\end{minted}



For basic functionality on objects you need to provide some methods:




\begin{lstlisting}
dsum(X::YourObject, Y::YourObject) ::YourObject
tensor_product(X::YourObject, Y::YourObject) ::YourObject
id(X::YourObject) ::YourMorphism
\end{lstlisting}



For morphisms you need




\begin{lstlisting}
dsum(f::YourMorphism, g::YourMorphism) ::YourMorphism
tensor_product(f::YourMorphism, g::YourMorphism) ::YourMorphism
compose(f::YourMorphism, g::YourMorphism) ::YourMorphism
\end{lstlisting}



Last you should give constructors for the one and zero




\begin{lstlisting}
one(C::YourCategory) ::YourObject
zero(C::YourCategory) ::YourObject
\end{lstlisting}



\hypertarget{4705679350657678226}{}


\chapter{Groethendieck Ring}



JuCat can compute the Groethendieck ring of a semisimple \texttt{MultiTensorCategory}, if provided with methods




\begin{lstlisting}
# Return the simple objects
simples(C::YourCategory) ::Vector{YourObject}

# Decompose into simple summands with multiplicity
decompose(X::YourObject) ::Vector{Tuple{YourObject, Int}}

# Check for isomorphy
isisomorphic(X::YourObject, Y::YourObject) ::Tuple{Bool, Union{YourMorphism, Nothing}}
\end{lstlisting}



Provided these methods exist you can call the function \texttt{groethendieck\_ring} on your category.



\begin{quote}
\textbf{Missing docstring.}

Missing docstring for \texttt{grothendieck\_ring}. Check Documenter{\textquotesingle}s build log for details.

\end{quote}


Since this is a generic methods it is by nature not the fastest. Thus if you know more about your category you should specify \texttt{grothendieck\_ring} on your type manually.



\hypertarget{3004524604150878810}{}


\section{Example}



Take a look at the convolution category:






\begin{minted}{julia}
G = symmetric_group(2)
X = gset(G, [1,2,3])
F = FiniteField(5)
Conv = ConvolutionCategory(X,F)

R,f = grothendieck_ring(Conv)
\end{minted}


\begin{lstlisting}
(Associative algebra of dimension 6 over Integers, JuCat.var"#to_gd#412"{Vector{ConvolutionObject{Nemo.gfp_elem, Oscar.PermGroup}}, Hecke.AlgAss{Int64}}(ConvolutionObject{Nemo.gfp_elem, Oscar.PermGroup}[Object in Convolution category over G-set with 3 elements., Object in Convolution category over G-set with 3 elements., Object in Convolution category over G-set with 3 elements., Object in Convolution category over G-set with 3 elements., Object in Convolution category over G-set with 3 elements., Object in Convolution category over G-set with 3 elements.], Associative algebra of dimension 6 over Integers))
\end{lstlisting}



\hypertarget{7504109423507221637}{}


\chapter{The S-Matrix}



For a braided fusion category with spherical structure and simple objects \(X_i\) the \(S\)-matrix is defined as



\begin{equation*}
\begin{split}\begin{aligned}
(S)_{ij} = Tr(c_{X_iX_j} \circ c_{X_jX_i})
\end{aligned}\end{split}\end{equation*}


Hence you see you need to provide a trace function and a braiding. The braiding




\begin{lstlisting}
braiding(X::YourObject, Y::YourObject) ::YourMorphism
\end{lstlisting}



There are two ways to archieve the trace: either you provide the trace by yourself




\begin{lstlisting}
tr(f::YourMorphism) ::YourMorphism
\end{lstlisting}



or you provide a spherical structure, duals, evaluation and coevaluation




\begin{lstlisting}
spherical(X::YourObject) ::YourMorphism
dual(X::YourObject) ::YourObject
ev(X::YourObject) ::YourMorphism
coev(X::YourObject) ::YourMorphism
\end{lstlisting}



with which the generic left categorical trace will be computed.



\begin{quote}
\textbf{Missing docstring.}

Missing docstring for \texttt{tr}. Check Documenter{\textquotesingle}s build log for details.

\end{quote}


\hypertarget{1764821590549139627}{}


\section{Example}



We can compute now the \(S\)-matrix of for the representations.




\begin{minted}{julia}
G = symmetric_group(3)
F = FiniteField(5)
Rep = RepresentationCategory(G,F)

smatrix(Rep)
\end{minted}


\begin{lstlisting}
3×3 Matrix{Nemo.gfp_elem}:
 1  1  2
 1  1  2
 2  2  4
\end{lstlisting}



\hypertarget{5903134002823049639}{}


\part{Showcase}



This page showcases the various page elements that are supported by Documenter. It should be read side-by-side with its source (\texttt{docs/src/showcase.md}) to see what syntax exactly is used to create the various elements.



\end{document}
