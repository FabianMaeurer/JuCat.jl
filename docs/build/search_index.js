var documenterSearchIndex = {"docs":
[{"location":"References.html#References","page":"References","title":"References","text":"","category":"section"},{"location":"References.html","page":"References","title":"References","text":"","category":"page"},{"location":"Interface/Categories.html","page":"Categories","title":"Categories","text":"using TensorCategories, Oscar","category":"page"},{"location":"Interface/Categories.html#Basics","page":"Categories","title":"Basics","text":"","category":"section"},{"location":"Interface/Categories.html","page":"Categories","title":"Categories","text":"The Interface is naturally based on three abstract types which  have to be extended:","category":"page"},{"location":"Interface/Categories.html","page":"Categories","title":"Categories","text":"abstract type Category end\nabstract type Object end\nabstract type Morphism end","category":"page"},{"location":"Interface/Categories.html#Categories","page":"Categories","title":"Categories","text":"","category":"section"},{"location":"Interface/Categories.html","page":"Categories","title":"Categories","text":"Categories without any additional structure do not need any  fields or methods. We follow the example of the category of finite sets.","category":"page"},{"location":"Interface/Categories.html","page":"Categories","title":"Categories","text":"struct FinSets <: Category end","category":"page"},{"location":"Interface/Categories.html#Objects","page":"Categories","title":"Objects","text":"","category":"section"},{"location":"Interface/Categories.html","page":"Categories","title":"Categories","text":"Objects need at least one field parent for the parent category or a method parentreturning the respective category. Any other information needed to work with the objects is arbitrary.","category":"page"},{"location":"Interface/Categories.html","page":"Categories","title":"Categories","text":"struct FinSetObject <: Object\n    parent::FinSets\n    set::Set\nend","category":"page"},{"location":"Interface/Categories.html","page":"Categories","title":"Categories","text":"Here we wrap a set to an object.","category":"page"},{"location":"Interface/Categories.html#Morphisms","page":"Categories","title":"Morphisms","text":"","category":"section"},{"location":"Interface/Categories.html","page":"Categories","title":"Categories","text":"Morphisms need to provide fields","category":"page"},{"location":"Interface/Categories.html","page":"Categories","title":"Categories","text":"domain\ncodomain","category":"page"},{"location":"Interface/Categories.html","page":"Categories","title":"Categories","text":"or methods","category":"page"},{"location":"Interface/Categories.html","page":"Categories","title":"Categories","text":"domain\ncodomain","category":"page"},{"location":"Interface/Categories.html","page":"Categories","title":"Categories","text":"For the category of sets we get","category":"page"},{"location":"Interface/Categories.html","page":"Categories","title":"Categories","text":"struct FinSetMorphism <: Morphism\n    domain::FinSetObject\n    codomain::FinSetObject\n    map\nend","category":"page"},{"location":"Interface/Categories.html","page":"Categories","title":"Categories","text":"Where one now can design any coding for a morphism of sets that fit the desired purpose.","category":"page"},{"location":"Interface/Categories.html#Required-Methods","page":"Categories","title":"Required Methods","text":"","category":"section"},{"location":"Interface/Categories.html","page":"Categories","title":"Categories","text":"Necessary methods to implemented for morphisms, objects and categories are","category":"page"},{"location":"Interface/Categories.html","page":"Categories","title":"Categories","text":"compose(f::YourMorphism, g::YourMorphism)::YourMorphism returning the composition g circ f.\nid(X::YourObject)::YourMorphism returning the identity morphism on X.\nHom(X::YourObject, Y::YourObject)::AbstractHomSet constructing an object <:AbstractHomSet.","category":"page"},{"location":"Interface/Categories.html","page":"Categories","title":"Categories","text":"Here anything extending AbstractHomspace needs to provide the fields ","category":"page"},{"location":"Interface/Categories.html","page":"Categories","title":"Categories","text":"domain\ncodomain","category":"page"},{"location":"Interface/Categories.html","page":"Categories","title":"Categories","text":"or methods","category":"page"},{"location":"Interface/Categories.html","page":"Categories","title":"Categories","text":"domain\ncodomain.","category":"page"},{"location":"Interface/Categories.html#Additional-methods","page":"Categories","title":"Additional methods","text":"","category":"section"},{"location":"Interface/Categories.html","page":"Categories","title":"Categories","text":"Your category might have more structure. For ","category":"page"},{"location":"Interface/Categories.html","page":"Categories","title":"Categories","text":"abelian\nmonoidal\ntensor","category":"page"},{"location":"Interface/Categories.html","page":"Categories","title":"Categories","text":"visit the corresponding chapter. The interface supports additionally the following constructions and operations.","category":"page"},{"location":"Interface/Categories.html#(Co)Products","page":"Categories","title":"(Co)Products","text":"","category":"section"},{"location":"Interface/Categories.html","page":"Categories","title":"Categories","text":"For a list of objects X_1X_n methods for the product shall return an object representing the categorical product prod X_i together with the projection maps p_i colon prod X_i to X_i. ","category":"page"},{"location":"Interface/Categories.html","page":"Categories","title":"Categories","text":"product(X::YourObject...)::Tuple{YourObject, Vector{YourMorphism}}","category":"page"},{"location":"Interface/Categories.html","page":"Categories","title":"Categories","text":"You may only implement a binary version product(X,Y) in which case TensorCategories extends it automatically to a list-version. Keep in mind that this might be devastating to the runtime, since iteratively applying a binary product involves composing morphisms which most likely is expensive.","category":"page"},{"location":"Interface/Categories.html","page":"Categories","title":"Categories","text":"TensorCategories will also generate an infix operator ","category":"page"},{"location":"Interface/Categories.html","page":"Categories","title":"Categories","text":"×(X::YourObject, Y::YourObject)::YourObject","category":"page"},{"location":"Interface/Categories.html","page":"Categories","title":"Categories","text":"that only returns the object in question.","category":"page"},{"location":"Interface/Categories.html","page":"Categories","title":"Categories","text":"Dually the same applies for a coproduct  Xᵢ.","category":"page"},{"location":"Interface/Categories.html","page":"Categories","title":"Categories","text":"coproduct(X::YourObject...)::Tuple{YourObject, Vector{YourMorphism}}","category":"page"},{"location":"SixJCategories/SixJCategories.html#j_categories","page":"6j-Symbols","title":"Fusion Categories from 6j-Symbols","text":"","category":"section"},{"location":"Center.html#The-Center-Construction","page":"The Center Construction","title":"The Center Construction","text":"","category":"section"},{"location":"index.html#TensorCategories.jl","page":"Home","title":"TensorCategories.jl","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"TensorCategories is a package under development with the intention to provide a framework as well a examples for computations in the realm of categories.","category":"page"},{"location":"index.html#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"You need to have Julia installed. For reliable results Julia version at least 1.6 is required. To use TensorCategories do the following:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"julia> import Pkg\njulia> Pkg.add(url = \"https://github.com/FabianMaeurer/TensorCategories.jl\")","category":"page"},{"location":"index.html#Usage","page":"Home","title":"Usage","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"To use TensorCategories the structures from the OSCAR-System are required. Here a minimal usage example.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"using TensorCategories, Oscar;\n\n# Define an Ising Fusion category\nI = Ising()\n\n# Define the categorical center\nC = Center(Ising())\n\n# Compute the S-matrix of the center\nS = smatrix(C)","category":"page"},{"location":"index.html#Acknowledgements","page":"Home","title":"Acknowledgements","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"This project was started under supervision of Prof. Ulrich Thiel  (University of Kaiserslautern). This work is a contribution to the SFB-TRR 195 'Symbolic Tools in Mathematics and their Application' of the German Research Foundation (DFG).","category":"page"},{"location":"Interface/Philosophy.html#The-Motivation","page":"Philosophy","title":"The Motivation","text":"","category":"section"},{"location":"Interface/Philosophy.html","page":"Philosophy","title":"Philosophy","text":"This package began its journey asking the question \"Can we play around  with explicit categorical entities in the computer?\".","category":"page"},{"location":"Interface/Philosophy.html","page":"Philosophy","title":"Philosophy","text":"By nature categorical operations and constructions are very generic and  can be applied as long as the objects (or morphisms) are fitting.  TensorCategories.jl provides an interface for categories with additional  structure, precisely additive, linear, abelian, monoidal, tensor and  fusion categories.","category":"page"},{"location":"Interface/Philosophy.html#Realizing-Categories-in-The-Computer","page":"Philosophy","title":"Realizing Categories in The Computer","text":"","category":"section"},{"location":"Interface/Philosophy.html","page":"Philosophy","title":"Philosophy","text":"Due to the nature of category theory the realization of certain categories  is very dependent on themselves. Thus the internal workings are generally  up to the developer. As long as the interface for the desired additional structures is implemented. ","category":"page"},{"location":"Interface/Philosophy.html","page":"Philosophy","title":"Philosophy","text":"Some kind of categories, i.e. fusion categories, are entirely described (up to equivalence) by discrete data known as 6j-symbols. Thus  for such categories we can provide a datatype SixJCategory  to quickly work with categories given by such data.","category":"page"},{"location":"Interface/Philosophy.html#Mathematical-Foundation","page":"Philosophy","title":"Mathematical Foundation","text":"","category":"section"},{"location":"Interface/Philosophy.html","page":"Philosophy","title":"Philosophy","text":"Throughout the package we will consider definitions and terminology as provided in Pavel Etingof, Shlomo Gelaki, Dmitri Nikshych, Victor Ostrik (2016).","category":"page"}]
}
