var documenterSearchIndex = {"docs":
[{"location":"CoherentSheaves/","page":"Coherent Sheaves","title":"Coherent Sheaves","text":"CurrentModule = TensorCategories","category":"page"},{"location":"CoherentSheaves/#Coherent-sheaves-on-Finite-Sets","page":"Coherent Sheaves","title":"Coherent sheaves on Finite Sets","text":"","category":"section"},{"location":"CoherentSheaves/","page":"Coherent Sheaves","title":"Coherent Sheaves","text":"Coherent sheaves on a finite set X are characterized by the stalks of the the elements x in X. I.e. a coherent sheaf on X is a collection of vector spaces V_x for each xin X. More generally for a group G and a G-set X we can define consider G-equivariant sheaves on X. In this case a sheaf is specified by representations of the stabilizers of representatives for the orbits.","category":"page"},{"location":"CoherentSheaves/#Equivariant-Coherent-Sheaves","page":"Coherent Sheaves","title":"Equivariant Coherent Sheaves","text":"","category":"section"},{"location":"CoherentSheaves/","page":"Coherent Sheaves","title":"Coherent Sheaves","text":"We provide the datatype","category":"page"},{"location":"CoherentSheaves/","page":"Coherent Sheaves","title":"Coherent Sheaves","text":"CoherentSheafCategoryObject <: CategoryObject","category":"page"},{"location":"CoherentSheaves/","page":"Coherent Sheaves","title":"Coherent Sheaves","text":"The category of equivariant coherent sheaves has type","category":"page"},{"location":"CoherentSheaves/","page":"Coherent Sheaves","title":"Coherent Sheaves","text":"CohSheaves <: MultiTensorCategory","category":"page"},{"location":"CoherentSheaves/","page":"Coherent Sheaves","title":"Coherent Sheaves","text":"and can be constructed via","category":"page"},{"location":"CoherentSheaves/","page":"Coherent Sheaves","title":"Coherent Sheaves","text":"CohSheaves","category":"page"},{"location":"CoherentSheaves/#TensorCategories.CohSheaves","page":"Coherent Sheaves","title":"TensorCategories.CohSheaves","text":"CohSheaves(X::GSet,F::Field)\n\nThe category of G-equivariant coherent sheafes on X.\n\n\n\n\n\nCohSheaves(X, F::Field)\n\nThe category of coherent sheafes on X.\n\n\n\n\n\n","category":"type"},{"location":"CoherentSheaves/","page":"Coherent Sheaves","title":"Coherent Sheaves","text":"Morphisms are given by morphisms of representations of the stalks and are of type","category":"page"},{"location":"CoherentSheaves/","page":"Coherent Sheaves","title":"Coherent Sheaves","text":"CohSheafCategoryMorphism{T,G} <: CategoryMorphism","category":"page"},{"location":"CoherentSheaves/","page":"Coherent Sheaves","title":"Coherent Sheaves","text":"Modules = [TensorCategories]\nPages = [\"CoherentSheaves.jl\"]","category":"page"},{"location":"CoherentSheaves/#TensorCategories.CohSheaves-Tuple{Any, Field}","page":"Coherent Sheaves","title":"TensorCategories.CohSheaves","text":"CohSheaves(X, F::Field)\n\nThe category of coherent sheafes on X.\n\n\n\n\n\n","category":"method"},{"location":"CoherentSheaves/#TensorCategories.CohSheaves-Tuple{GSet, Field}","page":"Coherent Sheaves","title":"TensorCategories.CohSheaves","text":"CohSheaves(X::GSet,F::Field)\n\nThe category of G-equivariant coherent sheafes on X.\n\n\n\n\n\n","category":"method"},{"location":"CoherentSheaves/#AbstractAlgebra.compose-Tuple{CohSheafCategoryMorphism, CohSheafCategoryMorphism}","page":"Coherent Sheaves","title":"AbstractAlgebra.compose","text":"compose(f::CohSheafCategoryMorphism, g::CohSheafCategoryMorphism)\n\nReturn the composition g∘f.\n\n\n\n\n\n","category":"method"},{"location":"CoherentSheaves/#AbstractAlgebra.direct_sum-Tuple{CohSheafCategoryMorphism, CohSheafCategoryMorphism}","page":"Coherent Sheaves","title":"AbstractAlgebra.direct_sum","text":"direct_sum(f::CohSheafCategoryMorphism, g::CohSheafCategoryMorphism)\n\nReturn the direct sum of morphisms of sheaves.\n\n\n\n\n\n","category":"method"},{"location":"CoherentSheaves/#AbstractAlgebra.direct_sum-Tuple{CohSheafCategoryObject, CohSheafCategoryObject}","page":"Coherent Sheaves","title":"AbstractAlgebra.direct_sum","text":"direct_sum(X::CohSheafCategoryObject, Y::CohSheafCategoryObject)\n\nReturn the direct sum of sheaves. Return also the inclusion and projection.\n\n\n\n\n\n","category":"method"},{"location":"CoherentSheaves/#AbstractAlgebra.is_isomorphic-Tuple{CohSheafCategoryObject, CohSheafCategoryObject}","page":"Coherent Sheaves","title":"AbstractAlgebra.is_isomorphic","text":"is_isomorphic(X::CohSheafCategoryObject, Y::CohSheafCategoryObject)\n\nCheck whether Xand Y are isomorphic and the isomorphism if possible.\n\n\n\n\n\n","category":"method"},{"location":"CoherentSheaves/#AbstractAlgebra.kernel-Tuple{CohSheafCategoryMorphism}","page":"Coherent Sheaves","title":"AbstractAlgebra.kernel","text":"kernel(f::CohSheafCategoryMorphism)\n\nReturn a tuple (K,k) where K is the kernel object and k is the inclusion.\n\n\n\n\n\n","category":"method"},{"location":"CoherentSheaves/#Base.inv-Tuple{CohSheafCategoryMorphism}","page":"Coherent Sheaves","title":"Base.inv","text":"inv(f::CohSheafCategoryMorphism)\n\nRetrn the inverse morphism of f.\n\n\n\n\n\n","category":"method"},{"location":"CoherentSheaves/#Base.one-Tuple{CohSheaves}","page":"Coherent Sheaves","title":"Base.one","text":"one(C::CohSheaves)\n\nReturn the one object in C.\n\n\n\n\n\n","category":"method"},{"location":"CoherentSheaves/#Base.zero-Tuple{CohSheaves}","page":"Coherent Sheaves","title":"Base.zero","text":"zero(C::CohSheaves)\n\nReturn the zero sheaf on the G-set.\n\n\n\n\n\n","category":"method"},{"location":"CoherentSheaves/#Hecke.cokernel-Tuple{CohSheafCategoryMorphism}","page":"Coherent Sheaves","title":"Hecke.cokernel","text":"cokernel(f::CohSheafCategoryMorphism)\n\nReturn a tuple (C,c) where C is the kernel object and c is the projection.\n\n\n\n\n\n","category":"method"},{"location":"CoherentSheaves/#Hecke.decompose-Tuple{CohSheafCategoryObject}","page":"Coherent Sheaves","title":"Hecke.decompose","text":"decompose(X::CohSheafCategoryObject)\n\nDecompose X into a direct sum of simple objects with multiplicity.\n\n\n\n\n\n","category":"method"},{"location":"CoherentSheaves/#Hecke.dual-Tuple{CohSheafCategoryObject}","page":"Coherent Sheaves","title":"Hecke.dual","text":"dual(X::CohSheafCategoryObject)\n\nReturn the dual object of X.\n\n\n\n\n\n","category":"method"},{"location":"CoherentSheaves/#Hecke.id-Tuple{CohSheafCategoryObject}","page":"Coherent Sheaves","title":"Hecke.id","text":"id(X::CohSheafCategoryObject)\n\nReturn the identity on X.\n\n\n\n\n\n","category":"method"},{"location":"CoherentSheaves/#Hecke.is_semisimple-Tuple{CohSheaves}","page":"Coherent Sheaves","title":"Hecke.is_semisimple","text":"is_semisimple(C::CohSheaves)\n\nReturn whether Cis semisimple.\n\n\n\n\n\n","category":"method"},{"location":"CoherentSheaves/#Hecke.tensor_product-Tuple{CohSheafCategoryMorphism, CohSheafCategoryMorphism}","page":"Coherent Sheaves","title":"Hecke.tensor_product","text":"tensor_product(f::CohSheafCategoryMorphism, g::CohSheafCategoryMorphism)\n\nReturn the tensor product of morphisms of equivariant coherent sheaves.\n\n\n\n\n\n","category":"method"},{"location":"CoherentSheaves/#Hecke.tensor_product-Tuple{CohSheafCategoryObject, CohSheafCategoryObject}","page":"Coherent Sheaves","title":"Hecke.tensor_product","text":"tensor_product(X::CohSheafCategoryObject, Y::CohSheafCategoryObject)\n\nReturn the tensor product of equivariant coherent sheaves.\n\n\n\n\n\n","category":"method"},{"location":"CoherentSheaves/#TensorCategories.Hom-Tuple{CohSheafCategoryObject, CohSheafCategoryObject}","page":"Coherent Sheaves","title":"TensorCategories.Hom","text":"Hom(X::CohSheafCategoryObject, Y::CohSheafCategoryObject)\n\nReturn Hom(XY) as a vector space.\n\n\n\n\n\n","category":"method"},{"location":"CoherentSheaves/#TensorCategories.Pullback-Tuple{CohSheaves, CohSheaves, Function}","page":"Coherent Sheaves","title":"TensorCategories.Pullback","text":"Pullback(C::CohSheaves, D::CohSheaves, f::Function)\n\nReturn the pullback functor C → D defined by the G-set map f::X → Y.\n\n\n\n\n\n","category":"method"},{"location":"CoherentSheaves/#TensorCategories.Pushforward-Tuple{CohSheaves, CohSheaves, Function}","page":"Coherent Sheaves","title":"TensorCategories.Pushforward","text":"Pushforward(C::CohSheaves, D::CohSheaves, f::Function)\n\nReturn the push forward functor C → D defined by the G-set map f::X → Y.\n\n\n\n\n\n","category":"method"},{"location":"CoherentSheaves/#TensorCategories.associator-Tuple{CohSheafCategoryObject, CohSheafCategoryObject, CohSheafCategoryObject}","page":"Coherent Sheaves","title":"TensorCategories.associator","text":"associator(X::CohSheafCategoryObject, Y::CohSheafCategoryObject, Z::CohSheafCategoryObject)\n\nReturn the associator isomorphism (X⊗Y)⊗Z → X⊗(Y⊗Z).\n\n\n\n\n\n","category":"method"},{"location":"CoherentSheaves/#TensorCategories.braiding-Tuple{CohSheafCategoryObject, CohSheafCategoryObject}","page":"Coherent Sheaves","title":"TensorCategories.braiding","text":"braiding(X::cohSheaf, Y::CohSheafCategoryObject)\n\nReturn the braiding isomoephism X⊗Y → Y⊗X.\n\n\n\n\n\n","category":"method"},{"location":"CoherentSheaves/#TensorCategories.coev-Tuple{CohSheafCategoryObject}","page":"Coherent Sheaves","title":"TensorCategories.coev","text":"coev(X::CohSheafCategoryObject)\n\nReturn the coevaluation morphism 1 → X⊗X∗.\n\n\n\n\n\n","category":"method"},{"location":"CoherentSheaves/#TensorCategories.ev-Tuple{CohSheafCategoryObject}","page":"Coherent Sheaves","title":"TensorCategories.ev","text":"ev(X::CohSheafCategoryObject)\n\nReturn the evaluation morphism X∗⊗X → 1.\n\n\n\n\n\n","category":"method"},{"location":"CoherentSheaves/#TensorCategories.simples-Tuple{CohSheaves}","page":"Coherent Sheaves","title":"TensorCategories.simples","text":"simples(C::CohSheaves)\n\nReturn the simple objects of C.\n\n\n\n\n\n","category":"method"},{"location":"CoherentSheaves/#TensorCategories.spherical-Tuple{CohSheafCategoryObject}","page":"Coherent Sheaves","title":"TensorCategories.spherical","text":"spherical(X::CohSheafCategoryObject)\n\nReturn the spherical structure isomorphism X → X∗∗.\n\n\n\n\n\n","category":"method"},{"location":"CoherentSheaves/#TensorCategories.stalks-Tuple{CohSheafCategoryObject}","page":"Coherent Sheaves","title":"TensorCategories.stalks","text":"stalks(X::CohSheafCategoryObject)\n\nReturn the stalks of X.\n\n\n\n\n\n","category":"method"},{"location":"CoherentSheaves/#TensorCategories.zero_morphism-Tuple{CohSheafCategoryObject, CohSheafCategoryObject}","page":"Coherent Sheaves","title":"TensorCategories.zero_morphism","text":"zero_morphism(X::CohSheafCategoryObject, Y::CohSheafCategoryObject)\n\nReturn the zero morphism 0:X → Y.\n\n\n\n\n\n","category":"method"},{"location":"CoherentSheaves/#Convolution-Category","page":"Coherent Sheaves","title":"Convolution Category","text":"","category":"section"},{"location":"CoherentSheaves/","page":"Coherent Sheaves","title":"Coherent Sheaves","text":"The objects of this category are again G-equivariant coherent sheaves on a finite G-set Xtimes X. But we endow them with a different monoidal product.","category":"page"},{"location":"CoherentSheaves/","page":"Coherent Sheaves","title":"Coherent Sheaves","text":"Let p_ij Xtimes Xtimes X to X times X be the canonical projections. Then we define the monoidal product of two coherent sheaves x and y","category":"page"},{"location":"CoherentSheaves/","page":"Coherent Sheaves","title":"Coherent Sheaves","text":"beginaligned\nxotimes y = p_13_ast(p_12^ast(x)otimes p_23^ast(y))\nendaligned","category":"page"},{"location":"CoherentSheaves/","page":"Coherent Sheaves","title":"Coherent Sheaves","text":"where otimesis the monoidal product of Coh(Xtimes Xtimes X). Similar for morphisms.","category":"page"},{"location":"CoherentSheaves/","page":"Coherent Sheaves","title":"Coherent Sheaves","text":"CategoryObjects in this category are of type","category":"page"},{"location":"CoherentSheaves/","page":"Coherent Sheaves","title":"Coherent Sheaves","text":"ConvolutionCategoryObject <: CategoryObject","category":"page"},{"location":"CoherentSheaves/","page":"Coherent Sheaves","title":"Coherent Sheaves","text":"while the convolution category is of type","category":"page"},{"location":"CoherentSheaves/","page":"Coherent Sheaves","title":"Coherent Sheaves","text":"ConvolutionCategory <: MultiTensorCategory","category":"page"},{"location":"CoherentSheaves/","page":"Coherent Sheaves","title":"Coherent Sheaves","text":"and can be constructed by","category":"page"},{"location":"CoherentSheaves/","page":"Coherent Sheaves","title":"Coherent Sheaves","text":"ConvolutionCategory","category":"page"},{"location":"CoherentSheaves/#TensorCategories.ConvolutionCategory","page":"Coherent Sheaves","title":"TensorCategories.ConvolutionCategory","text":"ConvolutionCategory(X::GSet, K::Field)\n\nReturn the category of equivariant coherent sheaves on X with convolution product.\n\n\n\n\n\nConvolutionCategory(X, K::Field)\n\nReturn the category of coherent sheaves on X with convolution product.\n\n\n\n\n\n","category":"type"},{"location":"CoherentSheaves/","page":"Coherent Sheaves","title":"Coherent Sheaves","text":"Morphisms are just morphisms of coherent sheaves with the new tensor product.","category":"page"},{"location":"CoherentSheaves/","page":"Coherent Sheaves","title":"Coherent Sheaves","text":"ConvolutionMorphism <: Morphism","category":"page"},{"location":"CoherentSheaves/","page":"Coherent Sheaves","title":"Coherent Sheaves","text":"Modules = [TensorCategories]\nPages = [\"ConvolutionCategory.jl\"]","category":"page"},{"location":"CoherentSheaves/#TensorCategories.ConvolutionCategory-Tuple{Any, Field}","page":"Coherent Sheaves","title":"TensorCategories.ConvolutionCategory","text":"ConvolutionCategory(X, K::Field)\n\nReturn the category of coherent sheaves on X with convolution product.\n\n\n\n\n\n","category":"method"},{"location":"CoherentSheaves/#TensorCategories.ConvolutionCategory-Tuple{GSet, Field}","page":"Coherent Sheaves","title":"TensorCategories.ConvolutionCategory","text":"ConvolutionCategory(X::GSet, K::Field)\n\nReturn the category of equivariant coherent sheaves on X with convolution product.\n\n\n\n\n\n","category":"method"},{"location":"CoherentSheaves/#AbstractAlgebra.direct_sum","page":"Coherent Sheaves","title":"AbstractAlgebra.direct_sum","text":"direct_sum(X::ConvolutionCategoryObject, Y::ConvolutionCategoryObject, morphisms::Bool = false)\n\ndocumentation\n\n\n\n\n\n","category":"function"},{"location":"CoherentSheaves/#AbstractAlgebra.direct_sum-Tuple{ConvolutionCategoryMorphism, ConvolutionCategoryMorphism}","page":"Coherent Sheaves","title":"AbstractAlgebra.direct_sum","text":"direct_sum(f::ConvolutionCategoryMorphism, g::ConvolutionCategoryMorphism)\n\nReturn the direct sum of morphisms of coherent sheaves (with convolution product).\n\n\n\n\n\n","category":"method"},{"location":"CoherentSheaves/#AbstractAlgebra.is_isomorphic-Tuple{ConvolutionCategoryObject, ConvolutionCategoryObject}","page":"Coherent Sheaves","title":"AbstractAlgebra.is_isomorphic","text":"is_isomorphic(X::ConvolutionCategoryObject, Y::ConvolutionCategoryObject)\n\nCheck whether Xand Yare isomorphic. Return the isomorphism if true.\n\n\n\n\n\n","category":"method"},{"location":"CoherentSheaves/#Base.one-Tuple{ConvolutionCategory}","page":"Coherent Sheaves","title":"Base.one","text":"one(C::ConvolutionCategory)\n\nReturn the one object in Conv(X).\n\n\n\n\n\n","category":"method"},{"location":"CoherentSheaves/#Base.zero-Tuple{ConvolutionCategory}","page":"Coherent Sheaves","title":"Base.zero","text":"zero(C::ConvolutionCategory)\n\nReturn the zero object in Conv(X).\n\n\n\n\n\n","category":"method"},{"location":"CoherentSheaves/#Hecke.decompose-Tuple{ConvolutionCategoryObject}","page":"Coherent Sheaves","title":"Hecke.decompose","text":"decompose(X::ConvolutionCategoryObject)\n\nDecompose X into a direct sum of simple objects with multiplicities.\n\n\n\n\n\n","category":"method"},{"location":"CoherentSheaves/#Hecke.is_semisimple-Tuple{ConvolutionCategory}","page":"Coherent Sheaves","title":"Hecke.is_semisimple","text":"is_semisimple(C::ConvolutionCategory)\n\nCheck whether C semisimple.\n\n\n\n\n\n","category":"method"},{"location":"CoherentSheaves/#Hecke.tensor_product-Tuple{ConvolutionCategoryMorphism, ConvolutionCategoryMorphism}","page":"Coherent Sheaves","title":"Hecke.tensor_product","text":"tensor_product(f::ConvolutionCategoryMorphism, g::ConvolutionCategoryMorphism)\n\nReturn the convolution product of morphisms of coherent sheaves.\n\n\n\n\n\n","category":"method"},{"location":"CoherentSheaves/#Hecke.tensor_product-Tuple{ConvolutionCategoryObject, ConvolutionCategoryObject}","page":"Coherent Sheaves","title":"Hecke.tensor_product","text":"tensor_product(X::ConvolutionCategoryObject, Y::ConvolutionCategoryObject)\n\nReturn the convolution product of coherent sheaves.\n\n\n\n\n\n","category":"method"},{"location":"CoherentSheaves/#TensorCategories.Hom-Tuple{ConvolutionCategoryObject, ConvolutionCategoryObject}","page":"Coherent Sheaves","title":"TensorCategories.Hom","text":"Hom(X::ConvolutionCategoryObject, Y::ConvolutionCategoryObject)\n\nReturn Hom(XY) as a vector space.\n\n\n\n\n\n","category":"method"},{"location":"CoherentSheaves/#TensorCategories.orbit_stabilizers-Tuple{ConvolutionCategory}","page":"Coherent Sheaves","title":"TensorCategories.orbit_stabilizers","text":"orbit_stabilizers(C::ConvolutionCategory)\n\nReturn the stabilizers of representatives of the orbits.\n\n\n\n\n\n","category":"method"},{"location":"CoherentSheaves/#TensorCategories.simples-Tuple{ConvolutionCategory}","page":"Coherent Sheaves","title":"TensorCategories.simples","text":"simples(C::ConvolutionCategory)\n\nReturn a list of simple objects in Conv(X).\n\n\n\n\n\n","category":"method"},{"location":"CoherentSheaves/#TensorCategories.stalks-Tuple{ConvolutionCategoryObject}","page":"Coherent Sheaves","title":"TensorCategories.stalks","text":"stalks(X::ConvolutionCategoryObject)\n\nReturn the stalks of the sheaf X.\n\n\n\n\n\n","category":"method"},{"location":"Interface/#A-Framework-for-Categories","page":"Introduction","title":"A Framework for Categories","text":"","category":"section"},{"location":"Interface/","page":"Introduction","title":"Introduction","text":"The main incentive of TensorCategories.jl is to provide abstract methods for categorical computations. TensorCategories.jl provides many generic types and methods which will work fine on custom categories implementing the interface.","category":"page"},{"location":"Interface/#The-Basics","page":"Introduction","title":"The Basics","text":"","category":"section"},{"location":"Interface/","page":"Introduction","title":"Introduction","text":"We provide the following abstract types to identify categories, objects and morphisms:","category":"page"},{"location":"Interface/","page":"Introduction","title":"Introduction","text":"abstract type Category end\nabstract type CategoryObject end\nabstract type CategoryMorphism end","category":"page"},{"location":"Interface/","page":"Introduction","title":"Introduction","text":"For basic functionality of YourCategory <: Category together with objects YourCategoryObject <: CategoryObject and morphisms YourMorphism <: CategoryMorphism you have to minimally build","category":"page"},{"location":"Interface/","page":"Introduction","title":"Introduction","text":"struct YourCategory <: Category end\n\nstruct YourCategoryObject <: CategoryObject\n  parent::YourCategory\nend\n\nstruct YourMorphism <: CategoryMorphism\n  domain::YourCategoryObject\n  codomain::YourCategoryObject\nend","category":"page"},{"location":"Interface/","page":"Introduction","title":"Introduction","text":"For objects you need to provide the following methods:","category":"page"},{"location":"Interface/","page":"Introduction","title":"Introduction","text":"id(X::YourCategoryObject) ::YourMorphism","category":"page"},{"location":"Interface/","page":"Introduction","title":"Introduction","text":"For morphisms you need","category":"page"},{"location":"Interface/","page":"Introduction","title":"Introduction","text":"compose(f::YourMorphism, g::YourMorphism) ::YourMorphism","category":"page"},{"location":"Interface/#Categories-with-Additional-Structure","page":"Introduction","title":"Categories with Additional Structure","text":"","category":"section"},{"location":"Interface/","page":"Introduction","title":"Introduction","text":"At the current state TensorCategories.jl knows about the following kinds of categories:","category":"page"},{"location":"Interface/","page":"Introduction","title":"Introduction","text":"k-linear \nadditive\nabelian\nmonoidal\nrigid monoidal\nbraided monoidal\nspherical\nKrull-Schmidt\n(multi)ring\n(multi)tensor\n(multi)fusion","category":"page"},{"location":"Interface/","page":"Introduction","title":"Introduction","text":"For the precise definitions take a look at EGNO, which we use as a general reference in most concerns. The above labels are generically tested by functions is_label(::Category)::Bool. In general it is only necessary to implement the necessary methods for a specific type. In some special cases it might be useful to explicitly falsify some labels. For example it is not feasible to check whether a preabelian category is in fact abelian. Thus TensorCategories will always see a preabelian category as abelian by omitting to check for (co)normality of epi/monomorphisms. ","category":"page"},{"location":"Interface/","page":"Introduction","title":"Introduction","text":"Structure/Property Required Structures/Properties Defining Methods Useful Methods\nAdditive  direct_sum(::YourObject,::YourObject)::Tuple{YourObject, Vector{YourMorphism}, Vector{YourMorphism}  direct_sum(::YourMorphism,::YourMoprhism)::YourMorphism  zero(::YourCategory)::YourObject  +(::YourMorphism, ::YourMorphism) \nLinear  base_ring(::YourCategory)::Field  *(::FieldElem,::YourMorphism  +(::YourMorphism, ::YourMorphism) \nAbelian Additive kernel(::YourMorphism)::Tuple{YourObject, YourMorphism}  cokernel(::YourMorphism)::Tuple{YourObject,YourMorphism} indecomposables(::YourCategory)::Vector{YourObject}  simples(::YourCategory)::Vector{YourObject}\nMonoidal  tensor_product(::YourObject,::YourObject)::YourObject  tensor_product(::YourMorphism,::YourMorphism)::YourMorphism  one(::YourCategory)::YourObject \nRigid Monoidal left_dual(X::YourObject)::YourObject  right_dual(X::YourObject)::YourObject  or, if the dual is two sided  dual(::YourObject)::YourObject  ev(::YourObject)::YourMorphism  coev(::YourObject)::YourMorphism \nBraided Monoidal braiding(X::YourObject, Y::YourObject)::YourMorphism \nSpherical Monoidal, Rigid spherical(X::YourObject)::YourMorphism \nKrull-Schmidt Additive, Linear Coming Soon \n(Multi)Ring Abelian, Monoidal, linear  \n(Multi)Tensor Multiring, Rigid  \n(Multi)Fusion Multitensor, Semisimple  ","category":"page"},{"location":"Interface/","page":"Introduction","title":"Introduction","text":"warn: Beware\nIf any of the above functions are implemented only partially it might be useful to manually specify the according label to be false. Otherwise there might be unwanted behavior. ","category":"page"},{"location":"Interface/","page":"Introduction","title":"Introduction","text":"note: Direct sums\nDirect sums always return the object and the corresponding inclusions and projections.","category":"page"},{"location":"Center/#The-Center-Construction","page":"The Center Construction","title":"The Center Construction","text":"","category":"section"},{"location":"Center/","page":"The Center Construction","title":"The Center Construction","text":"Let Cbe a fusion category.  ","category":"page"},{"location":"Center/","page":"The Center Construction","title":"The Center Construction","text":"Modules = [TensorCategories]\nPages = [\"Center.jl\"]\nOrder = [:function]","category":"page"},{"location":"Center/#AbstractAlgebra.Generic.dim-Tuple{CenterCategoryObject}","page":"The Center Construction","title":"AbstractAlgebra.Generic.dim","text":"dim(X::CenterCategoryObject)\n\nReturn the categorical dimension of X.\n\n\n\n\n\n","category":"method"},{"location":"Center/#AbstractAlgebra.compose-Tuple{CenterCategoryMorphism, CenterCategoryMorphism}","page":"The Center Construction","title":"AbstractAlgebra.compose","text":"compose(f::CenterCategoryMorphism, g::CenterCategoryMorphism)\n\nReturn the composition g∘f.\n\n\n\n\n\n","category":"method"},{"location":"Center/#AbstractAlgebra.direct_sum-Tuple{CenterCategoryMorphism, CenterCategoryMorphism}","page":"The Center Construction","title":"AbstractAlgebra.direct_sum","text":"direct_sum(f::CenterCategoryMorphism, g::CenterCategoryMorphism)\n\nReturn the direct sum of f and g.\n\n\n\n\n\n","category":"method"},{"location":"Center/#AbstractAlgebra.direct_sum-Tuple{CenterCategoryObject, CenterCategoryObject}","page":"The Center Construction","title":"AbstractAlgebra.direct_sum","text":"direct_sum(X::CenterCategoryObject, Y::CenterCategoryObject)\n\nReturn the direct sum object of X and Y.\n\n\n\n\n\n","category":"method"},{"location":"Center/#AbstractAlgebra.is_isomorphic-Tuple{CenterCategoryObject, CenterCategoryObject}","page":"The Center Construction","title":"AbstractAlgebra.is_isomorphic","text":"is_isomorphic(X::CenterCategoryObject, Y::CenterCategoryObject)\n\nCheck if X≃Y. Return (true, m) where mis an isomorphism if true, else return (false,nothing).\n\n\n\n\n\n","category":"method"},{"location":"Center/#AbstractAlgebra.kernel-Tuple{CenterCategoryMorphism}","page":"The Center Construction","title":"AbstractAlgebra.kernel","text":"kernel(f::CenterMoprhism)\n\nReturn a tuple (K,k) where Kis the kernel object and kis the inclusion.\n\n\n\n\n\n","category":"method"},{"location":"Center/#Base.inv-Tuple{CenterCategoryMorphism}","page":"The Center Construction","title":"Base.inv","text":"inv(f::CenterCategoryMorphism)\n\nReturn the inverse of fif possible.\n\n\n\n\n\n","category":"method"},{"location":"Center/#Base.one-Tuple{CenterCategory}","page":"The Center Construction","title":"Base.one","text":"one(C::CenterCategory)\n\nReturn the one object of C.\n\n\n\n\n\n","category":"method"},{"location":"Center/#Base.zero-Tuple{CenterCategory}","page":"The Center Construction","title":"Base.zero","text":"zero(C::CenterCategory)\n\nReturn the zero object of C.\n\n\n\n\n\n","category":"method"},{"location":"Center/#Hecke.cokernel-Tuple{CenterCategoryMorphism}","page":"The Center Construction","title":"Hecke.cokernel","text":"cokernel(f::CenterCategoryMorphism)\n\nReturn a tuple (C,c) where Cis the cokernel object and cis the projection.\n\n\n\n\n\n","category":"method"},{"location":"Center/#Hecke.dual-Tuple{CenterCategoryObject}","page":"The Center Construction","title":"Hecke.dual","text":"dual(X::CenterCategoryObject)\n\nReturn the (left) dual object of X.\n\n\n\n\n\n","category":"method"},{"location":"Center/#Hecke.id-Tuple{CenterCategoryObject}","page":"The Center Construction","title":"Hecke.id","text":"id(X::CenterCategoryObject)\n\nReturn the identity on X.\n\n\n\n\n\n","category":"method"},{"location":"Center/#Hecke.is_central","page":"The Center Construction","title":"Hecke.is_central","text":"is_central(Z::CategoryObject)\n\nReturn true if Z is in the categorical center, i.e. there exists a half-braiding on Z.\n\n\n\n\n\n","category":"function"},{"location":"Center/#Hecke.tensor_product-Tuple{CenterCategoryMorphism, CenterCategoryMorphism}","page":"The Center Construction","title":"Hecke.tensor_product","text":"tensor_product(f::CenterCategoryMorphism,g::CenterCategoryMorphism)\n\nReturn the tensor product of f and g.\n\n\n\n\n\n","category":"method"},{"location":"Center/#Hecke.tensor_product-Tuple{CenterCategoryObject, CenterCategoryObject}","page":"The Center Construction","title":"Hecke.tensor_product","text":"tensor_product(X::CenterCategoryObject, Y::CenterCategoryObject)\n\nReturn the tensor product of X and Y.\n\n\n\n\n\n","category":"method"},{"location":"Center/#LinearAlgebra.tr-Tuple{CenterCategoryMorphism}","page":"The Center Construction","title":"LinearAlgebra.tr","text":"tr(f:::CenterCategoryMorphism)\n\nReturn the categorical trace of f.\n\n\n\n\n\n","category":"method"},{"location":"Center/#TensorCategories.Center-Tuple{Category}","page":"The Center Construction","title":"TensorCategories.Center","text":"Center(C::Category)\n\nReturn the Drinfeld center of C.\n\n\n\n\n\n","category":"method"},{"location":"Center/#TensorCategories.add_simple!-Tuple{CenterCategory, CenterCategoryObject}","page":"The Center Construction","title":"TensorCategories.add_simple!","text":"add_simple!(C::CenterCategory, S::CenterCategoryObject)\n\nAdd the simple object S to the vector of simple objects.\n\n\n\n\n\n","category":"method"},{"location":"Center/#TensorCategories.associator-Tuple{CenterCategoryObject, CenterCategoryObject, CenterCategoryObject}","page":"The Center Construction","title":"TensorCategories.associator","text":"associator(X::CenterCategoryObject, Y::CenterCategoryObject, Z::CenterCategoryObject)\n\nReturn the associator isomorphism (X⊗Y)⊗Z → X⊗(Y⊗Z).\n\n\n\n\n\n","category":"method"},{"location":"Center/#TensorCategories.braiding-Tuple{CenterCategoryObject, CenterCategoryObject}","page":"The Center Construction","title":"TensorCategories.braiding","text":"braiding(X::CenterCategoryObject, Y::CenterCategoryObject)\n\nReturn the braiding isomorphism X⊗Y → Y⊗X.\n\n\n\n\n\n","category":"method"},{"location":"Center/#TensorCategories.coev-Tuple{CenterCategoryObject}","page":"The Center Construction","title":"TensorCategories.coev","text":"coev(X::CenterCategoryObject)\n\nReturn the coevaluation morphism 1 → X⊗X∗.\n\n\n\n\n\n","category":"method"},{"location":"Center/#TensorCategories.ev-Tuple{CenterCategoryObject}","page":"The Center Construction","title":"TensorCategories.ev","text":"ev(X::CenterCategoryObject)\n\nReturn the evaluation morphism X⊗X → 1.\n\n\n\n\n\n","category":"method"},{"location":"Center/#TensorCategories.half_braiding-Tuple{CenterCategoryObject}","page":"The Center Construction","title":"TensorCategories.half_braiding","text":"half_braiding(Z::CenterCategoryObject)\n\nReturn  a vector with half braiding morphisms Z⊗S → S⊗Z for all simple objects S.\n\n\n\n\n\n","category":"method"},{"location":"Center/#TensorCategories.half_braidings-Tuple{CategoryObject}","page":"The Center Construction","title":"TensorCategories.half_braidings","text":"half_braidings(Z::CategoryObject)\n\nReturn all objects in the center lying over Z.\n\n\n\n\n\n","category":"method"},{"location":"Center/#TensorCategories.object-Tuple{CenterCategoryObject}","page":"The Center Construction","title":"TensorCategories.object","text":"object(X::CenterCategoryObject)\n\nReturn the onderlying object in 𝒞.\n\n\n\n\n\n","category":"method"},{"location":"Center/#TensorCategories.simples-Tuple{CenterCategory}","page":"The Center Construction","title":"TensorCategories.simples","text":"simples(C::CenterCategory)\n\nReturn a vector containing the simple objects of C. The list might be incomplete.\n\n\n\n\n\n","category":"method"},{"location":"Center/#TensorCategories.spherical-Tuple{CenterCategoryObject}","page":"The Center Construction","title":"TensorCategories.spherical","text":"spherical(X::CenterCategoryObject)\n\nReturn the spherical structure X → X∗∗ of X.\n\n\n\n\n\n","category":"method"},{"location":"Center/#TensorCategories.zero_morphism-Tuple{CenterCategoryObject, CenterCategoryObject}","page":"The Center Construction","title":"TensorCategories.zero_morphism","text":"zero_morphism(X::CenterCategoryObject, Y::CenterCategoryObject)\n\nReturn the zero morphism 0:X → Y.\n\n\n\n\n\n","category":"method"},{"location":"Representations/","page":"Representations","title":"Representations","text":"CurrentModule = TensorCategories","category":"page"},{"location":"Representations/#Representations","page":"Representations","title":"Representations","text":"","category":"section"},{"location":"Representations/","page":"Representations","title":"Representations","text":"We provide a simple abstract type hierarchy for representation categories:","category":"page"},{"location":"Representations/","page":"Representations","title":"Representations","text":"abstract type RepresentationCategory <:Category","category":"page"},{"location":"Representations/","page":"Representations","title":"Representations","text":"A representation category always requires the field","category":"page"},{"location":"Representations/","page":"Representations","title":"Representations","text":"base_ring::Field","category":"page"},{"location":"Representations/#Representations-of-Finite-groups","page":"Representations","title":"Representations of Finite groups","text":"","category":"section"},{"location":"Representations/","page":"Representations","title":"Representations","text":"Let G be a finite group. We consider the category of finite dimensional k-representations of G.","category":"page"},{"location":"Representations/","page":"Representations","title":"Representations","text":"GroupRepresentationCategory <: RepresentationCategory","category":"page"},{"location":"Representations/","page":"Representations","title":"Representations","text":"Build it with the constructor","category":"page"},{"location":"Representations/","page":"Representations","title":"Representations","text":"RepresentationCategory(::GAPGroup, ::Field)","category":"page"},{"location":"Representations/#TensorCategories.RepresentationCategory-Tuple{Oscar.GAPGroup, Field}","page":"Representations","title":"TensorCategories.RepresentationCategory","text":"RepresentationCategory(G::GAPGroup, F::Field)\n\nCategory of finite dimensonal group representations of G.\n\n\n\n\n\n","category":"method"},{"location":"Representations/","page":"Representations","title":"Representations","text":"A group representation is defined by a group homomorphism from G into a finite dimensional vector space k^n. These objects are of type","category":"page"},{"location":"Representations/","page":"Representations","title":"Representations","text":"GroupRepresentationCategoryObject <: RepresentationCategoryObject","category":"page"},{"location":"Representations/","page":"Representations","title":"Representations","text":"They are constructed in one of two ways, either by imag\"es of generators or by a function","category":"page"},{"location":"Representations/","page":"Representations","title":"Representations","text":"Representation(::GAPGroup,::Vector,::Vector)\nRepresentation(::GAPGroup,::Function)","category":"page"},{"location":"Representations/#TensorCategories.Representation-Tuple{Oscar.GAPGroup, Vector{T} where T, Vector{T} where T}","page":"Representations","title":"TensorCategories.Representation","text":"Representation(G::GAPGroup, pre_img::Vector, img::Vector)\n\nGroup representation defined by the images of generators of G.\n\n\n\n\n\n","category":"method"},{"location":"Representations/#TensorCategories.Representation-Tuple{Oscar.GAPGroup, Function}","page":"Representations","title":"TensorCategories.Representation","text":"Representation(G::GAPGroup, m::Function)\n\nGroup representation defined by m:G -> Mat_n.\n\n\n\n\n\n","category":"method"},{"location":"Representations/","page":"Representations","title":"Representations","text":"where in both cases the images are required to be fitting MatrixElem objects.","category":"page"},{"location":"Representations/","page":"Representations","title":"Representations","text":"Since group representation categories are tensor categories, we again have methods for the important operations","category":"page"},{"location":"Representations/","page":"Representations","title":"Representations","text":"Modules = [TensorCategories]\nPages = [\"GroupRepresentations.jl\"]","category":"page"},{"location":"Representations/#AbstractAlgebra.direct_sum-Tuple{GroupRepresentation, GroupRepresentation}","page":"Representations","title":"AbstractAlgebra.direct_sum","text":"direct_sum(ρ::GroupRepresentation, τ::GroupRepresentation, morphisms::Bool = false)\n\nReturn the direct sum of representations with the corresponding injections und projections.\n\n\n\n\n\n","category":"method"},{"location":"Representations/#AbstractAlgebra.direct_sum-Tuple{GroupRepresentationCategoryMorphism, GroupRepresentationCategoryMorphism}","page":"Representations","title":"AbstractAlgebra.direct_sum","text":"direct_sum(f::GroupRepresentationCategoryMorphism, g::GroupRepresentationCategoryMorphism)\n\nDirect sum of morphisms of representations.\n\n\n\n\n\n","category":"method"},{"location":"Representations/#AbstractAlgebra.is_isomorphic-Tuple{GroupRepresentation, GroupRepresentation}","page":"Representations","title":"AbstractAlgebra.is_isomorphic","text":"is_isomorphic(σ::GroupRepresentation, τ::GroupRepresentation)\n\nCheck whether σ and τ are isomorphic. If true return the isomorphism.\n\n\n\n\n\n","category":"method"},{"location":"Representations/#Base.one-Tuple{GroupRepresentationCategory}","page":"Representations","title":"Base.one","text":"one(Rep::GroupRepresentationCategory)\n\nReturn the trivial representation.\n\n\n\n\n\n","category":"method"},{"location":"Representations/#Base.parent-Tuple{GroupRepresentation}","page":"Representations","title":"Base.parent","text":"parent(ρ::GroupRepresentation)\n\nReturn the parent representation category of ρ.\n\n\n\n\n\n","category":"method"},{"location":"Representations/#Base.zero-Tuple{GroupRepresentationCategory}","page":"Representations","title":"Base.zero","text":"zero(Rep::GroupRepresentationCategory)\n\nReturn the zero reprensentation.\n\n\n\n\n\n","category":"method"},{"location":"Representations/#Hecke.decompose-Tuple{GroupRepresentation}","page":"Representations","title":"Hecke.decompose","text":"decompose(σ::GroupRepresentation)\n\nDecompose the representation into a direct sum of simple objects. Return a list of tuples with simple objects and multiplicities.\n\n\n\n\n\n","category":"method"},{"location":"Representations/#Hecke.id-Tuple{GroupRepresentation}","page":"Representations","title":"Hecke.id","text":"id(ρ::GroupRepresentation)\n\nReturn the identity on ρ.\n\n\n\n\n\n","category":"method"},{"location":"Representations/#Hecke.is_semisimple-Tuple{GroupRepresentationCategory}","page":"Representations","title":"Hecke.is_semisimple","text":"is_semisimple(C::GroupRepresentationCategory)\n\nReturn true if C is semisimple else false.\n\n\n\n\n\n","category":"method"},{"location":"Representations/#Hecke.tensor_product-Tuple{GroupRepresentation, GroupRepresentation}","page":"Representations","title":"Hecke.tensor_product","text":"tensor_product(ρ::GroupRepresentation, τ::GroupRepresentation)\n\nReturn the tensor product of representations.\n\n\n\n\n\n","category":"method"},{"location":"Representations/#Hecke.tensor_product-Tuple{GroupRepresentationCategoryMorphism, GroupRepresentationCategoryMorphism}","page":"Representations","title":"Hecke.tensor_product","text":"tensor_product(f::GroupRepresentationCategoryMorphism, g::GroupRepresentationCategoryMorphism)\n\nReturn the tensor product of morphisms of representations.\n\n\n\n\n\n","category":"method"},{"location":"Representations/#TensorCategories.Hom-Tuple{GroupRepresentation, GroupRepresentation}","page":"Representations","title":"TensorCategories.Hom","text":"Hom(σ::GroupRepresentation, τ::GroupRepresentation)\n\nReturn the hom-space of the representations as a vector space.\n\n\n\n\n\n","category":"method"},{"location":"Representations/#TensorCategories.Morphism-Tuple{GroupRepresentation, GroupRepresentation, MatElem}","page":"Representations","title":"TensorCategories.Morphism","text":"Morphism(ρ::GroupRepresentation, τ::GroupRepresentation, m::MatElem; check = true)\n\nMorphism between representations defined by m. If check == false equivariancy will not be checked.\n\n\n\n\n\n","category":"method"},{"location":"Representations/#TensorCategories.simples-Tuple{GroupRepresentationCategory}","page":"Representations","title":"TensorCategories.simples","text":"simples(Rep::GroupRepresentationCategory)\n\nReturn a list of the simple objects in Rep.\n\n\n\n\n\n","category":"method"},{"location":"RingCategory/","page":"Idea","title":"Idea","text":"using TensorCategories, Oscar","category":"page"},{"location":"RingCategory/#Semisimple-Ring-Categories-from-6j-Symbols","page":"Idea","title":"Semisimple Ring Categories from 6j-Symbols","text":"","category":"section"},{"location":"RingCategory/","page":"Idea","title":"Idea","text":"We provide a structure RingCategory for finite semisimple skeletal (multi)ring categories. ","category":"page"},{"location":"RingCategory/","page":"Idea","title":"Idea","text":"They are constructed by setting the multiplication table for the monoidal product and associativity for the simple objects. CategoryObjects in finite semisimple ring categories are just vectors with multiplicities of the simple objects in the decomposition. Thus morphism are vectors of matrices of according size.","category":"page"},{"location":"RingCategory/","page":"Idea","title":"Idea","text":"As an example we will construct the Ising fusion category. This is a fusion category with three simple objects 1, chi and X. The multiplication is given by chi otimes chi = 1, chi otimes X = X otimes chi = X and X otimes X = 1 oplus chi. There are precisely 3 non-trivial 6j-symbols Phi_X^chiXchi = -1, Phi_chi^XchiX = -1 und Phi_X^XXX = frac1sqrt 2beginpmatrix 1  1  1  -1endpmatrix.","category":"page"},{"location":"RingCategory/","page":"Idea","title":"Idea","text":"F = QQBar\nI = RingCategory(F,[\"𝟙\", \"χ\", \"X\"])\n\nM = zeros(Int,3,3,3)\n\nM[1,1,:] = [1,0,0]\nM[1,2,:] = [0,1,0]\nM[1,3,:] = [0,0,1]\nM[2,1,:] = [0,1,0]\nM[2,2,:] = [1,0,0]\nM[2,3,:] = [0,0,1]\nM[3,1,:] = [0,0,1]\nM[3,2,:] = [0,0,1]\nM[3,3,:] = [1,1,0]\n\nset_tensor_product!(I,M)\n\nset_associator!(I, 2,3,2,3, [-1])\nset_associator!(I, 3,2,3,2, [-1])\nset_associator!(I, 3,3,3,3, inv(sqrt(F(2))).*[1 1; 1 -1])","category":"page"},{"location":"RingCategory/","page":"Idea","title":"Idea","text":"At the current state of development the unit object has to be set manually. Other structure like spherical structures are set as identities, which might or might not be correct. If you know your category to be spherical you can set the canonical spherical structure such that dim X_i = mathrmfpdimX_i by applying set_canonical_spherical(RingCategory) to it. It is also possible to set a braiding.","category":"page"},{"location":"RingCategory/","page":"Idea","title":"Idea","text":"set_one!(I, [1,0,0])\n\n#set one of four possible braidings \nα = root_of_unity(F,8)\n\nbraid = Array{MatElem,3}(undef, 3,3,3)\n\nbraid[1,1,:] = matrices(id(I[1]))\nbraid[1,2,:] = braid[2,1,:] = matrices(id(I[2]))\nbraid[2,2,:] = -1 .* matrices(id(I[1]))\n\nbraid[1,3,:] = braid[3,1,:] = matrices(id(I[3]))\nbraid[2,3,:] = braid[3,2,:] = α^2 .* matrices(id(I[3]))\n\nbraid[3,3,:] = matrices((α * id(I[1]) ⊕ (α^7 * id(I[2]))))\n\nset_braiding!(I,braid)\n\n# Check the pentagon equations for all simple objects in I\n@show pentagon_axiom(I)","category":"page"},{"location":"VectorSpaces/","page":"Vector Spaces","title":"Vector Spaces","text":"using TensorCategories, Oscar","category":"page"},{"location":"VectorSpaces/#Vector-Space-Categories","page":"Vector Spaces","title":"Vector Space Categories","text":"","category":"section"},{"location":"VectorSpaces/","page":"Vector Spaces","title":"Vector Spaces","text":"Vector spaces in TensorCategories are of the abstract type","category":"page"},{"location":"VectorSpaces/","page":"Vector Spaces","title":"Vector Spaces","text":"abstract type VectorSpaceCategoryObject <: CategoryObject end","category":"page"},{"location":"VectorSpaces/","page":"Vector Spaces","title":"Vector Spaces","text":"All objects with vector space structure like hom-spaces are and should be implemented as a subtype of this type. They always need the following fields:","category":"page"},{"location":"VectorSpaces/","page":"Vector Spaces","title":"Vector Spaces","text":"basis::Vector\nparent::Category","category":"page"},{"location":"VectorSpaces/#Finite-Dimensional-VectorSpaces","page":"Vector Spaces","title":"Finite Dimensional VectorSpaces","text":"","category":"section"},{"location":"VectorSpaces/","page":"Vector Spaces","title":"Vector Spaces","text":"The simplest example to provide are the finite dimensional vector spaces over a field. This category has type","category":"page"},{"location":"VectorSpaces/","page":"Vector Spaces","title":"Vector Spaces","text":"VectorSpaces <: TensorCategory","category":"page"},{"location":"VectorSpaces/","page":"Vector Spaces","title":"Vector Spaces","text":"and can be constructed like so:","category":"page"},{"location":"VectorSpaces/","page":"Vector Spaces","title":"Vector Spaces","text":"F,a = FiniteField(5,2)\nVec = VectorSpaces()","category":"page"},{"location":"VectorSpaces/","page":"Vector Spaces","title":"Vector Spaces","text":"CategoryObjects of this category are of the type","category":"page"},{"location":"VectorSpaces/","page":"Vector Spaces","title":"Vector Spaces","text":"VSCategoryObject <: VectorSpaceCategoryObject","category":"page"},{"location":"VectorSpaces/","page":"Vector Spaces","title":"Vector Spaces","text":"Every vector space object is defined by a basis and a base field provided by the parent category.","category":"page"},{"location":"VectorSpaces/","page":"Vector Spaces","title":"Vector Spaces","text":"VectorSpaceCategoryObject\nVectorSpaceCategoryObject(::VectorSpaces,::Int)","category":"page"},{"location":"VectorSpaces/#TensorCategories.VectorSpaceCategoryObject","page":"Vector Spaces","title":"TensorCategories.VectorSpaceCategoryObject","text":"VectorSpaceCategoryObject\n\nAn object in the category of finite dimensional vector spaces.\n\n\n\n\n\n","category":"type"},{"location":"VectorSpaces/#TensorCategories.VectorSpaceCategoryObject-Tuple{VectorSpaces, Int64}","page":"Vector Spaces","title":"TensorCategories.VectorSpaceCategoryObject","text":"VectorSpaceCategoryObject(Vec::VectorSpaces, n::Int64)\nVectorSpaceCategoryObject(K::Field, n::Int)\nVectorSpaceCategoryObject(Vec::VectorSpaces, basis::Vector)\nVectorSpaceCategoryObject(K::Field, basis::Vector)\n\nThe n-dimensional vector space with basis v1,..,vn (or other specified basis)\n\n\n\n\n\n","category":"method"},{"location":"VectorSpaces/","page":"Vector Spaces","title":"Vector Spaces","text":"Morphisms in this Category are defined only by matrices of matching dimensions. They are typed as","category":"page"},{"location":"VectorSpaces/","page":"Vector Spaces","title":"Vector Spaces","text":"VSCategoryMorphism <: CategoryMorphism","category":"page"},{"location":"VectorSpaces/","page":"Vector Spaces","title":"Vector Spaces","text":"and constructed giving a domain, codomain and matrix element.","category":"page"},{"location":"VectorSpaces/","page":"Vector Spaces","title":"Vector Spaces","text":"CategoryMorphism(::VectorSpaceCategoryObject, ::VectorSpaceCategoryObject, ::MatElem)","category":"page"},{"location":"VectorSpaces/#Graded-Vector-Spaces","page":"Vector Spaces","title":"Graded Vector Spaces","text":"","category":"section"},{"location":"VectorSpaces/","page":"Vector Spaces","title":"Vector Spaces","text":"Very similar we have the category of finite dimensional (twisted) G-graded vector spaces for a finite group G. We have the type","category":"page"},{"location":"VectorSpaces/","page":"Vector Spaces","title":"Vector Spaces","text":"GradedVectorSpaces <: VectorSpaces","category":"page"},{"location":"VectorSpaces/","page":"Vector Spaces","title":"Vector Spaces","text":"and they are constructed in straightforward manner","category":"page"},{"location":"VectorSpaces/","page":"Vector Spaces","title":"Vector Spaces","text":"G = symmetric_group(6)\nVecG = GradedVectorSpaces(G)","category":"page"},{"location":"VectorSpaces/","page":"Vector Spaces","title":"Vector Spaces","text":"To add a non-trivial associator (twist) there is another constructor. ","category":"page"},{"location":"VectorSpaces/","page":"Vector Spaces","title":"Vector Spaces","text":"TwistedGradedVectorSpaces","category":"page"},{"location":"VectorSpaces/#TensorCategories.TwistedGradedVectorSpaces","page":"Vector Spaces","title":"TensorCategories.TwistedGradedVectorSpaces","text":"TwistedGradedVectorSpaces(G::GAPGroup, i::Int)\n\nConstruct the category of twisted graded vectorspaces with the i-th 3-cocycle.\n\n\n\n\n\n","category":"function"},{"location":"VectorSpaces/","page":"Vector Spaces","title":"Vector Spaces","text":"Graded vector spaces decompose into direct sums of vector spaces for each element in G.","category":"page"},{"location":"VectorSpaces/","page":"Vector Spaces","title":"Vector Spaces","text":"GVSCategoryObject <: VectorSpaceCategoryObject","category":"page"},{"location":"VectorSpaces/","page":"Vector Spaces","title":"Vector Spaces","text":"G = symmetric_group(5)\ng,s = gens(G)\nV1 = VectorSpaceCategoryObject(QQ,5)\nV2 = VectorSpaceCategoryObject(QQ, [:v, :w])\nW = VectorSpaceCategoryObject(g => V1, s => V2, g*s => V1⊗V2)","category":"page"},{"location":"VectorSpaces/","page":"Vector Spaces","title":"Vector Spaces","text":"Morphisms are implemented analogously by pairs of group elements and vector space objects.","category":"page"},{"location":"VectorSpaces/","page":"Vector Spaces","title":"Vector Spaces","text":"GVSCategoryMorphism <: CategoryMorphism","category":"page"},{"location":"VectorSpaces/","page":"Vector Spaces","title":"Vector Spaces","text":"The constructor is given by ","category":"page"},{"location":"VectorSpaces/","page":"Vector Spaces","title":"Vector Spaces","text":"Morphism(::GVSCategoryObject, ::GVSCategoryObject,::MatElem) where {G, S <: VectorSpaceCategoryMorphism}","category":"page"},{"location":"VectorSpaces/#Functionality","page":"Vector Spaces","title":"Functionality","text":"","category":"section"},{"location":"VectorSpaces/","page":"Vector Spaces","title":"Vector Spaces","text":"(Graded) vector spaces form a fusion category. Thus the methods for direct sums, tensor products, dual, one and zero object are all implemented.","category":"page"},{"location":"VectorSpaces/","page":"Vector Spaces","title":"Vector Spaces","text":"Modules = [TensorCategories]\nPages = [\"VectorSpaces.jl\"]\nOrder = [:function]","category":"page"},{"location":"VectorSpaces/#AbstractAlgebra.Generic.dim-Tuple{VectorSpaceCategoryObject}","page":"Vector Spaces","title":"AbstractAlgebra.Generic.dim","text":"dim(V::VectorSpaceCategoryObject) = length(V.basis)\n\nReturn the vector space dimension of V.\n\n\n\n\n\n","category":"method"},{"location":"VectorSpaces/#AbstractAlgebra.direct_sum-Tuple{GVSCategoryObject, GVSCategoryObject}","page":"Vector Spaces","title":"AbstractAlgebra.direct_sum","text":"function direct_sum(V::GVSCategoryObject, W::GVSCategoryObject)\n\nReturn the direct sum object VW.\n\n\n\n\n\n","category":"method"},{"location":"VectorSpaces/#AbstractAlgebra.direct_sum-Tuple{VectorSpaceCategoryMorphism, VectorSpaceCategoryMorphism}","page":"Vector Spaces","title":"AbstractAlgebra.direct_sum","text":"direct_sum(f::VectorSpaceCategoryMorphism{T},g::VectorSpaceCategoryMorphism{T}) where T\n\nReturn the direct sum of morphisms of vector spaces.\n\n\n\n\n\n","category":"method"},{"location":"VectorSpaces/#AbstractAlgebra.direct_sum-Tuple{VectorSpaceCategoryObject, VectorSpaceCategoryObject}","page":"Vector Spaces","title":"AbstractAlgebra.direct_sum","text":"direct_sum(X::VectorSpaceCategoryObject{T}, Y::VectorSpaceCategoryObject{T}) where {T}\n\nDirect sum of vector spaces together with the embedding morphisms.\n\n\n\n\n\n","category":"method"},{"location":"VectorSpaces/#AbstractAlgebra.is_isomorphic-Tuple{GVSCategoryObject, GVSCategoryObject}","page":"Vector Spaces","title":"AbstractAlgebra.is_isomorphic","text":"function is_isomorphic(V::GVSCategoryObject, W::GVSCategoryObject)\n\nCheck whether Vand Ware isomorphic as G-graded vector spaces and return an isomorphism in the positive case.\n\n\n\n\n\n","category":"method"},{"location":"VectorSpaces/#AbstractAlgebra.is_isomorphic-Tuple{VectorSpaceCategoryObject, VectorSpaceCategoryObject}","page":"Vector Spaces","title":"AbstractAlgebra.is_isomorphic","text":"is_isomorphic(V::VSCategoryObject, W::VSCategoryObject)\n\nCheck whether V and Ware isomorphic. Return the isomorphisms if existent.\n\n\n\n\n\n","category":"method"},{"location":"VectorSpaces/#AbstractAlgebra.kernel-Tuple{GVSCategoryMorphism}","page":"Vector Spaces","title":"AbstractAlgebra.kernel","text":"function kernel(f::GVSCategoryMorphism)\n\nReturn the graded vector space kernel of f.\n\n\n\n\n\n","category":"method"},{"location":"VectorSpaces/#Base.one-Tuple{GradedVectorSpaces}","page":"Vector Spaces","title":"Base.one","text":"function one(C::GradedVectorSpaces)\n\nReturn k as the one dimensional graded vector space.\n\n\n\n\n\n","category":"method"},{"location":"VectorSpaces/#Base.one-Tuple{VectorSpaces}","page":"Vector Spaces","title":"Base.one","text":"one(Vec::VectorSpaces) = VectorSpaceCategoryObject(base_ring(Vec),1)\n\nReturn the one-dimensional vector space.\n\n\n\n\n\n","category":"method"},{"location":"VectorSpaces/#Base.zero-Tuple{GradedVectorSpaces}","page":"Vector Spaces","title":"Base.zero","text":"function zero(C::GradedVectorSpaces)\n\nReturn the zero diemsnional graded vector space.\n\n\n\n\n\n","category":"method"},{"location":"VectorSpaces/#Base.zero-Tuple{VectorSpaces}","page":"Vector Spaces","title":"Base.zero","text":"zero(Vec::VectorSpaces) = VectorSpaceCategoryObject(base_ring(Vec), 0)\n\nReturn the zero-dimensional vector space.\n\n\n\n\n\n","category":"method"},{"location":"VectorSpaces/#Hecke.cokernel-Tuple{GVSCategoryMorphism}","page":"Vector Spaces","title":"Hecke.cokernel","text":"function cokernel(f::GVSCategoryMorphism)\n\nReturn the graded vector space cokernel of f.\n\n\n\n\n\n","category":"method"},{"location":"VectorSpaces/#Hecke.decompose-Tuple{GVSCategoryObject}","page":"Vector Spaces","title":"Hecke.decompose","text":"function decompose(V::GVSCategoryObject)\n\nReturn a vector with the simple objects together with their multiplicities VXi.\n\n\n\n\n\n","category":"method"},{"location":"VectorSpaces/#Hecke.dual-Tuple{GVSCategoryObject}","page":"Vector Spaces","title":"Hecke.dual","text":"function dual(V::GVSCategoryObject)\n\nReturn the graded dual vector space of V.\n\n\n\n\n\n","category":"method"},{"location":"VectorSpaces/#Hecke.id-Tuple{VectorSpaceCategoryObject}","page":"Vector Spaces","title":"Hecke.id","text":"id(X::VectorSpaceCategoryObject{T}) where T\n\nReturn the identity on the vector space X.\n\n\n\n\n\n","category":"method"},{"location":"VectorSpaces/#Hecke.tensor_product-Tuple{GVSCategoryObject, GVSCategoryObject}","page":"Vector Spaces","title":"Hecke.tensor_product","text":"function tensor_product(V::GVSCategoryObject, W::GVSCategoryObject)\n\nReturn the tensor product VW.\n\n\n\n\n\n","category":"method"},{"location":"VectorSpaces/#Hecke.tensor_product-Tuple{VectorSpaceCategoryMorphism, VectorSpaceCategoryMorphism}","page":"Vector Spaces","title":"Hecke.tensor_product","text":"tensor_product(f::VectorSpaceCategoryMorphism, g::VectorSpaceCategoryMorphism)\n\nReturn the tensor product of vector space morphisms.\n\n\n\n\n\n","category":"method"},{"location":"VectorSpaces/#Hecke.tensor_product-Tuple{VectorSpaceCategoryObject, VectorSpaceCategoryObject}","page":"Vector Spaces","title":"Hecke.tensor_product","text":"tensor_product(X::VectorSpaceCategoryObject{T}, Y::VectorSpaceCategoryObject{T}) where {T,S1,S2}\n\nReturn the tensor product of vector spaces.\n\n\n\n\n\n","category":"method"},{"location":"VectorSpaces/#TensorCategories.Hom-Tuple{GVSCategoryObject, GVSCategoryObject}","page":"Vector Spaces","title":"TensorCategories.Hom","text":"function Hom(V::GVSCategoryObject, W::GVSCategoryObject)\n\nReturn the space of morphisms between graded vector spaces V and W.\n\n\n\n\n\n","category":"method"},{"location":"VectorSpaces/#TensorCategories.Hom-Tuple{VectorSpaceCategoryObject, VectorSpaceCategoryObject}","page":"Vector Spaces","title":"TensorCategories.Hom","text":"Hom(X::VectorSpaceCategoryObject, Y::VectorSpaceCategoryObject)\n\nReturn the Hom(XY`) as a vector space.\n\n\n\n\n\n","category":"method"},{"location":"VectorSpaces/#TensorCategories.Morphism-Tuple{GVSCategoryObject, GVSCategoryObject, MatElem}","page":"Vector Spaces","title":"TensorCategories.Morphism","text":"function Morphism(V::GVSCategoryObject, Y::GVSCategoryObject, m::MatElem)\n\nReturn the morphism V  Wdefined by m.\n\n\n\n\n\n","category":"method"},{"location":"VectorSpaces/#TensorCategories.Morphism-Tuple{MatElem}","page":"Vector Spaces","title":"TensorCategories.Morphism","text":"Morphism(m::MatElem)\n\nVector space morphisms defined by m.\n\n\n\n\n\n","category":"method"},{"location":"VectorSpaces/#TensorCategories.Morphism-Tuple{VectorSpaceCategoryObject, VectorSpaceCategoryObject, MatElem}","page":"Vector Spaces","title":"TensorCategories.Morphism","text":"Morphism(X::VectorSpaceCategoryObject, Y::VectorSpaceCategoryObject, m::MatElem)\n\nReturn a morphism in the category of vector spaces defined by m.\n\n\n\n\n\n","category":"method"},{"location":"VectorSpaces/#TensorCategories.associator-Tuple{GVSCategoryObject, GVSCategoryObject, GVSCategoryObject}","page":"Vector Spaces","title":"TensorCategories.associator","text":"function associator(U::GVSCategoryObject, V::GVSCategoryObject, W::GVSCategoryObject)\n\nreturn the associator isomorphism (UV)W  U(VW).\n\n\n\n\n\n","category":"method"},{"location":"VectorSpaces/#TensorCategories.associator-Tuple{VectorSpaceCategoryObject, VectorSpaceCategoryObject, VectorSpaceCategoryObject}","page":"Vector Spaces","title":"TensorCategories.associator","text":"associator(X::VectorSpaceCategoryObject, Y::VectorSpaceCategoryObject, Z::VectorSpaceCategoryObject)\n\nReturn the associator isomorphism a::(X⊗Y)⊗Z -> X⊗(Y⊗Z).\n\n\n\n\n\n","category":"method"},{"location":"VectorSpaces/#TensorCategories.ev-Tuple{GVSCategoryObject}","page":"Vector Spaces","title":"TensorCategories.ev","text":"function ev(V::GVSCategoryObject)\n\nReturn the evaluation map V*V  𝟙.\n\n\n\n\n\n","category":"method"},{"location":"VectorSpaces/#TensorCategories.simples-Tuple{GradedVectorSpaces}","page":"Vector Spaces","title":"TensorCategories.simples","text":"function simples(C::GradedVectorSpaces)\n\nReturn a vector containing the simple objects of C.\n\n\n\n\n\n","category":"method"},{"location":"showcase/#Showcase","page":"Showcase","title":"Showcase","text":"","category":"section"},{"location":"showcase/","page":"Showcase","title":"Showcase","text":"This page showcases the various page elements that are supported by Documenter. It should be read side-by-side with its source (docs/src/showcase.md) to see what syntax exactly is used to create the various elements.","category":"page"},{"location":"ZPlusRings/#\\mathbb-Z_-Rings","page":"ℤ₊-Rings","title":"mathbb Z_+-Rings","text":"","category":"section"},{"location":"ZPlusRings/","page":"ℤ₊-Rings","title":"ℤ₊-Rings","text":"Especially for the grothendieck ring of a tensor category the notion of a mathbb Z_+-Ring is very important. ","category":"page"},{"location":"ZPlusRings/","page":"ℤ₊-Rings","title":"ℤ₊-Rings","text":"A mathbb Z_+-Ring is a ring that is free as a mathbb Z-module together with a basis b_i_i in I such that b_ib_j = sumlimits_i in Ic_ij^k b_k with c_ij^k in mathbb Z_+ and the unit beein a non-negative linear combination of the basis elements. We call such a ring unital if the unit is a basis element.","category":"page"},{"location":"ZPlusRings/","page":"ℤ₊-Rings","title":"ℤ₊-Rings","text":"In TensorCategories this is realized with the structures","category":"page"},{"location":"ZPlusRings/","page":"ℤ₊-Rings","title":"ℤ₊-Rings","text":"ZPlusRing\nZPlusRingElem","category":"page"},{"location":"ZPlusRings/","page":"ℤ₊-Rings","title":"ℤ₊-Rings","text":"which extend the structures Oscar.Ring and Oscar.RingElemrespectively. ","category":"page"},{"location":"ZPlusRings/","page":"ℤ₊-Rings","title":"ℤ₊-Rings","text":"Modules = [TensorCategories]\nPages = [\"FusionRings.jl\"]\n````\n## Grothendieck Rings\n\nOne way to generate ``\\mathbb Z_+``-rings is by computing the Grothendieck ring of a multitensor category.\n","category":"page"},{"location":"ZPlusRings/","page":"ℤ₊-Rings","title":"ℤ₊-Rings","text":"@docs grothendieck_ring ```","category":"page"},{"location":"ToDo/#Groethendieck-Ring","page":"Groethendieck Ring","title":"Groethendieck Ring","text":"","category":"section"},{"location":"ToDo/","page":"Groethendieck Ring","title":"Groethendieck Ring","text":"TensorCategories can compute the Groethendieck ring of a semisimple multitensor category, if provided with methods","category":"page"},{"location":"ToDo/","page":"Groethendieck Ring","title":"Groethendieck Ring","text":"# Return the simple objects\nsimples(C::YourCategory) ::Vector{YourCategoryObject}\n\n# Decompose into simple summands with multiplicity\ndecompose(X::YourCategoryObject) ::Vector{Tuple{YourCategoryObject, Int}}\n\n# Check for isomorphy\nis_isomorphic(X::YourCategoryObject, Y::YourCategoryObject) ::Tuple{Bool, Union{YourMorphism, Nothing}}","category":"page"},{"location":"ToDo/","page":"Groethendieck Ring","title":"Groethendieck Ring","text":"Provided these methods exist you can call the function grothendieck_ring on your category.","category":"page"},{"location":"ToDo/","page":"Groethendieck Ring","title":"Groethendieck Ring","text":"grothendieck_ring","category":"page"},{"location":"ToDo/#TensorCategories.grothendieck_ring","page":"Groethendieck Ring","title":"TensorCategories.grothendieck_ring","text":"grothendieck_ring(C::Category)\n\nReturn the grothendieck ring of the multiring category C.\n\n\n\n\n\n","category":"function"},{"location":"ToDo/","page":"Groethendieck Ring","title":"Groethendieck Ring","text":"Since this is a generic methods it is by nature not the fastest. Thus if you know more about your category you should specify grothendieck_ring on your type manually.","category":"page"},{"location":"ToDo/#Example","page":"Groethendieck Ring","title":"Example","text":"","category":"section"},{"location":"ToDo/","page":"Groethendieck Ring","title":"Groethendieck Ring","text":"Take a look at the convolution category:","category":"page"},{"location":"ToDo/","page":"Groethendieck Ring","title":"Groethendieck Ring","text":"using TensorCategories, Oscar","category":"page"},{"location":"ToDo/","page":"Groethendieck Ring","title":"Groethendieck Ring","text":"G = symmetric_group(2)\nX = gset(G, [1,2,3])\nF,_ = FiniteField(5)\nConv = ConvolutionCategory(X,F)\n\nR,f = grothendieck_ring(Conv)","category":"page"},{"location":"ToDo/#The-S-Matrix","page":"Groethendieck Ring","title":"The S-Matrix","text":"","category":"section"},{"location":"ToDo/","page":"Groethendieck Ring","title":"Groethendieck Ring","text":"For a braided fusion category with spherical structure and simple objects X_i the S-matrix is defined as","category":"page"},{"location":"ToDo/","page":"Groethendieck Ring","title":"Groethendieck Ring","text":"beginaligned\n(S)_ij = Tr(c_X_iX_j circ c_X_jX_i)\nendaligned","category":"page"},{"location":"ToDo/","page":"Groethendieck Ring","title":"Groethendieck Ring","text":"Hence you see you need to provide a trace function and a braiding. The braiding","category":"page"},{"location":"ToDo/","page":"Groethendieck Ring","title":"Groethendieck Ring","text":"braiding(X::YourCategoryObject, Y::YourCategoryObject) ::YourMorphism","category":"page"},{"location":"ToDo/","page":"Groethendieck Ring","title":"Groethendieck Ring","text":"There are two ways to archive the trace: either you provide the trace by yourself","category":"page"},{"location":"ToDo/","page":"Groethendieck Ring","title":"Groethendieck Ring","text":"tr(f::YourMorphism) ::YourMorphism","category":"page"},{"location":"ToDo/","page":"Groethendieck Ring","title":"Groethendieck Ring","text":"or you provide a spherical structure, duals, evaluation and coevaluation","category":"page"},{"location":"ToDo/","page":"Groethendieck Ring","title":"Groethendieck Ring","text":"spherical(X::YourCategoryObject) ::YourMorphism\ndual(X::YourCategoryObject) ::YourCategoryObject\nev(X::YourCategoryObject) ::YourMorphism\ncoev(X::YourCategoryObject) ::YourMorphism","category":"page"},{"location":"ToDo/","page":"Groethendieck Ring","title":"Groethendieck Ring","text":"with which the generic left categorical trace will be computed.","category":"page"},{"location":"ToDo/","page":"Groethendieck Ring","title":"Groethendieck Ring","text":"tr","category":"page"},{"location":"ToDo/#LinearAlgebra.tr","page":"Groethendieck Ring","title":"LinearAlgebra.tr","text":"tr(f:::CenterCategoryMorphism)\n\nReturn the categorical trace of f.\n\n\n\n\n\n","category":"function"},{"location":"ToDo/#Example-2","page":"Groethendieck Ring","title":"Example","text":"","category":"section"},{"location":"ToDo/","page":"Groethendieck Ring","title":"Groethendieck Ring","text":"We can compute now the S-matrix of for the representations.","category":"page"},{"location":"ToDo/","page":"Groethendieck Ring","title":"Groethendieck Ring","text":"G = symmetric_group(3)\nF,_ = FiniteField(5)\nRep = RepresentationCategory(G,F)\n\nsmatrix(Rep)","category":"page"},{"location":"RingCatExamples/#Tambara-Yamagami-Fusion-Categories","page":"Examples","title":"Tambara Yamagami Fusion Categories","text":"","category":"section"},{"location":"RingCatExamples/","page":"Examples","title":"Examples","text":"For a detailed intrutuction to Tambara-Yamagami categories we refer to TY.","category":"page"},{"location":"RingCatExamples/","page":"Examples","title":"Examples","text":"Let A be a finite abelian group with n elements. The Tambara-Yamagami fusion category TY_A has n+1 simple objects of which n are invertible. We denote the simple objects by a_1a_nin A and m. The monoidal product is given by a_i otimes a_j = a_icdot a_j, a_i otimes m = m otimes a_i = m and m otimes m = a_1 oplus cdots oplus a_n. ","category":"page"},{"location":"#TensorCategories.jl","page":"Home","title":"TensorCategories.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"TensorCategories is a package under development with the intention to provide a framework as well a examples for computations in the realm of categories.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"You need to have Julia installed. For reliable results Julia version at least 1.6 is required. To use TensorCategories do the following:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> import Pkg\njulia> Pkg.add(url = \"https://github.com/FabianMaeurer/TensorCategories.jl\")","category":"page"},{"location":"#Usage","page":"Home","title":"Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To use TensorCategories the structures from the OSCAR-System are required. Here a minimal usage example.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using TensorCategories, Oscar;\n\n# Define an Ising Fusion category\nI = Ising()\n\n# Define the categorical center\nC = Center(Ising())\n\n# Compute the S-matrix of the center\nS = smatrix(C)","category":"page"},{"location":"#Acknowledgements","page":"Home","title":"Acknowledgements","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This project was started under supervision of Prof. Ulrich Thiel  (University of Kaiserslautern). This work is a contribution to the SFB-TRR 195 'Symbolic Tools in Mathematics and their Application' of the German Research Foundation (DFG).","category":"page"}]
}
