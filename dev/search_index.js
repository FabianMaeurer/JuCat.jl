var documenterSearchIndex = {"docs":
[{"location":"showcase/#Showcase","page":"Showcase","title":"Showcase","text":"","category":"section"},{"location":"showcase/","page":"Showcase","title":"Showcase","text":"This page showcases the various page elements that are supported by Documenter. It should be read side-by-side with its source (docs/src/showcase.md) to see what syntax exactly is used to create the various elements.","category":"page"},{"location":"CoherentSheaves/","page":"Coherent Sheaves","title":"Coherent Sheaves","text":"CurrentModule = TensorCategories","category":"page"},{"location":"CoherentSheaves/#Coherent-sheaves-on-Finite-Sets","page":"Coherent Sheaves","title":"Coherent sheaves on Finite Sets","text":"","category":"section"},{"location":"CoherentSheaves/","page":"Coherent Sheaves","title":"Coherent Sheaves","text":"Coherent sheaves on a finite set X are characterised by the stalks of the the elements x in X. I.e. a coherent sheaf on X is a collection of vector spaces V_x for each xin X. More generally for a group G and a G-set X we can define consider G-equivariant sheaves on X. In this case a sheaf is specified by representations of the stabilizers of representatives for the orbits.","category":"page"},{"location":"CoherentSheaves/#Equivariant-Coherent-Sheaves","page":"Coherent Sheaves","title":"Equivariant Coherent Sheaves","text":"","category":"section"},{"location":"CoherentSheaves/","page":"Coherent Sheaves","title":"Coherent Sheaves","text":"We provide the datatype","category":"page"},{"location":"CoherentSheaves/","page":"Coherent Sheaves","title":"Coherent Sheaves","text":"CoherentSheaf <: Object","category":"page"},{"location":"CoherentSheaves/","page":"Coherent Sheaves","title":"Coherent Sheaves","text":"The category of equivariant coherent sheafes has type","category":"page"},{"location":"CoherentSheaves/","page":"Coherent Sheaves","title":"Coherent Sheaves","text":"CohSheaves <: MultiTensorCategory","category":"page"},{"location":"CoherentSheaves/","page":"Coherent Sheaves","title":"Coherent Sheaves","text":"and can be constructed via","category":"page"},{"location":"CoherentSheaves/","page":"Coherent Sheaves","title":"Coherent Sheaves","text":"CohSheaves","category":"page"},{"location":"CoherentSheaves/#TensorCategories.CohSheaves","page":"Coherent Sheaves","title":"TensorCategories.CohSheaves","text":"CohSheaves(X::GSet,F::Field)\n\nThe category of G-equivariant coherent sheafes on X.\n\n\n\n\n\nCohSheaves(X, F::Field)\n\nThe category of coherent sheafes on X.\n\n\n\n\n\n","category":"type"},{"location":"CoherentSheaves/","page":"Coherent Sheaves","title":"Coherent Sheaves","text":"Morphisms are given by morphisms of representations of the stalks and are of type","category":"page"},{"location":"CoherentSheaves/","page":"Coherent Sheaves","title":"Coherent Sheaves","text":"CohSheafMorphism{T,G} <: Morphism","category":"page"},{"location":"CoherentSheaves/","page":"Coherent Sheaves","title":"Coherent Sheaves","text":"Modules = [TensorCategories]\nPages = [\"CoherentSheaves.jl\"]","category":"page"},{"location":"CoherentSheaves/#TensorCategories.CohSheaves-Tuple{Any, AbstractAlgebra.Field}","page":"Coherent Sheaves","title":"TensorCategories.CohSheaves","text":"CohSheaves(X, F::Field)\n\nThe category of coherent sheafes on X.\n\n\n\n\n\n","category":"method"},{"location":"CoherentSheaves/#TensorCategories.CohSheaves-Tuple{GSet, AbstractAlgebra.Field}","page":"Coherent Sheaves","title":"TensorCategories.CohSheaves","text":"CohSheaves(X::GSet,F::Field)\n\nThe category of G-equivariant coherent sheafes on X.\n\n\n\n\n\n","category":"method"},{"location":"CoherentSheaves/#AbstractAlgebra.compose-Tuple{CohSheafMorphism, CohSheafMorphism}","page":"Coherent Sheaves","title":"AbstractAlgebra.compose","text":"compose(f::CohSheafMorphism, g::CohSheafMorphism)\n\nReturn the composition g∘f.\n\n\n\n\n\n","category":"method"},{"location":"CoherentSheaves/#AbstractAlgebra.isisomorphic-Tuple{CohSheaf, CohSheaf}","page":"Coherent Sheaves","title":"AbstractAlgebra.isisomorphic","text":"isisomorphic(X::CohSheaf, Y::CohSheaf)\n\nCheck whether Xand Y are isomorphic and the isomorphism if possible.\n\n\n\n\n\n","category":"method"},{"location":"CoherentSheaves/#AbstractAlgebra.kernel-Tuple{CohSheafMorphism}","page":"Coherent Sheaves","title":"AbstractAlgebra.kernel","text":"kernel(f::CohSheafMorphism)\n\nReturn a tuple (K,k) where K is the kernel object and k is the inclusion.\n\n\n\n\n\n","category":"method"},{"location":"CoherentSheaves/#Base.inv-Tuple{CohSheafMorphism}","page":"Coherent Sheaves","title":"Base.inv","text":"inv(f::CohSheafMorphism)\n\nRetrn the inverse morphism of f.\n\n\n\n\n\n","category":"method"},{"location":"CoherentSheaves/#Base.one-Tuple{CohSheaves}","page":"Coherent Sheaves","title":"Base.one","text":"one(C::CohSheaves)\n\nReturn the one object in C.\n\n\n\n\n\n","category":"method"},{"location":"CoherentSheaves/#Base.zero-Tuple{CohSheaves}","page":"Coherent Sheaves","title":"Base.zero","text":"zero(C::CohSheaves)\n\nReturn the zero sheaf on the G-set.\n\n\n\n\n\n","category":"method"},{"location":"CoherentSheaves/#Hecke.cokernel-Tuple{CohSheafMorphism}","page":"Coherent Sheaves","title":"Hecke.cokernel","text":"cokernel(f::CohSheafMorphism)\n\nReturn a tuple (C,c) where C is the kernel object and c is the projection.\n\n\n\n\n\n","category":"method"},{"location":"CoherentSheaves/#Hecke.decompose-Tuple{CohSheaf}","page":"Coherent Sheaves","title":"Hecke.decompose","text":"decompose(X::CohSheaf)\n\nDecompose X into a direct sum of simple objects with multiplicity.\n\n\n\n\n\n","category":"method"},{"location":"CoherentSheaves/#Hecke.dual-Tuple{CohSheaf}","page":"Coherent Sheaves","title":"Hecke.dual","text":"dual(X::CohSheaf)\n\nReturn the dual object of X.\n\n\n\n\n\n","category":"method"},{"location":"CoherentSheaves/#Hecke.id-Tuple{CohSheaf}","page":"Coherent Sheaves","title":"Hecke.id","text":"id(X::CohSheaf)\n\nReturn the identity on X.\n\n\n\n\n\n","category":"method"},{"location":"CoherentSheaves/#Hecke.tensor_product-Tuple{CohSheaf, CohSheaf}","page":"Coherent Sheaves","title":"Hecke.tensor_product","text":"tensor_product(X::CohSheaf, Y::CohSheaf)\n\nReturn the tensor product of equivariant coherent sheaves.\n\n\n\n\n\n","category":"method"},{"location":"CoherentSheaves/#Hecke.tensor_product-Tuple{CohSheafMorphism, CohSheafMorphism}","page":"Coherent Sheaves","title":"Hecke.tensor_product","text":"tensor_product(f::CohSheafMorphism, g::CohSheafMorphism)\n\nReturn the tensor product of morphisms of equivariant coherent sheaves.\n\n\n\n\n\n","category":"method"},{"location":"CoherentSheaves/#Oscar.issemisimple-Tuple{CohSheaves}","page":"Coherent Sheaves","title":"Oscar.issemisimple","text":"issemisimple(C::CohSheaves)\n\nReturn whether Cis semisimple.\n\n\n\n\n\n","category":"method"},{"location":"CoherentSheaves/#TensorCategories.Hom-Tuple{CohSheaf, CohSheaf}","page":"Coherent Sheaves","title":"TensorCategories.Hom","text":"Hom(X::CohSheaf, Y::CohSheaf)\n\nReturn Hom(XY) as a vector space.\n\n\n\n\n\n","category":"method"},{"location":"CoherentSheaves/#TensorCategories.Pullback-Tuple{CohSheaves, CohSheaves, Function}","page":"Coherent Sheaves","title":"TensorCategories.Pullback","text":"Pullback(C::CohSheaves, D::CohSheaves, f::Function)\n\nReturn the pullback functor C → D defined by the G-set map f::X → Y.\n\n\n\n\n\n","category":"method"},{"location":"CoherentSheaves/#TensorCategories.Pushforward-Tuple{CohSheaves, CohSheaves, Function}","page":"Coherent Sheaves","title":"TensorCategories.Pushforward","text":"Pushforward(C::CohSheaves, D::CohSheaves, f::Function)\n\nReturn the push forward functor C → D defined by the G-set map f::X → Y.\n\n\n\n\n\n","category":"method"},{"location":"CoherentSheaves/#TensorCategories.associator-Tuple{CohSheaf, CohSheaf, CohSheaf}","page":"Coherent Sheaves","title":"TensorCategories.associator","text":"associator(X::CohSheaf, Y::CohSheaf, Z::CohSheaf)\n\nReturn the associator isomorphism (X⊗Y)⊗Z → X⊗(Y⊗Z).\n\n\n\n\n\n","category":"method"},{"location":"CoherentSheaves/#TensorCategories.braiding-Tuple{CohSheaf, CohSheaf}","page":"Coherent Sheaves","title":"TensorCategories.braiding","text":"braiding(X::cohSheaf, Y::CohSheaf)\n\nReturn the braiding isomoephism X⊗Y → Y⊗X.\n\n\n\n\n\n","category":"method"},{"location":"CoherentSheaves/#TensorCategories.coev-Tuple{CohSheaf}","page":"Coherent Sheaves","title":"TensorCategories.coev","text":"coev(X::CohSheaf)\n\nReturn the coevaluation morphism 1 → X⊗X∗.\n\n\n\n\n\n","category":"method"},{"location":"CoherentSheaves/#TensorCategories.dsum","page":"Coherent Sheaves","title":"TensorCategories.dsum","text":"dsum(X::CohSheaf, Y::CohSheaf, morphisms::Bool = false)\n\nReturn the direct sum of sheaves. Return also the inclusion and projection if morphisms = true.\n\n\n\n\n\n","category":"function"},{"location":"CoherentSheaves/#TensorCategories.dsum-Tuple{CohSheafMorphism, CohSheafMorphism}","page":"Coherent Sheaves","title":"TensorCategories.dsum","text":"dsum(f::CohSheafMorphism, g::CohSheafMorphism)\n\nReturn the direct sum of morphisms of sheaves.\n\n\n\n\n\n","category":"method"},{"location":"CoherentSheaves/#TensorCategories.ev-Tuple{CohSheaf}","page":"Coherent Sheaves","title":"TensorCategories.ev","text":"ev(X::CohSheaf)\n\nReturn the evaluation morphism X∗⊗X → 1.\n\n\n\n\n\n","category":"method"},{"location":"CoherentSheaves/#TensorCategories.simples-Tuple{CohSheaves}","page":"Coherent Sheaves","title":"TensorCategories.simples","text":"simples(C::CohSheaves)\n\nReturn the simple objects of C.\n\n\n\n\n\n","category":"method"},{"location":"CoherentSheaves/#TensorCategories.spherical-Tuple{CohSheaf}","page":"Coherent Sheaves","title":"TensorCategories.spherical","text":"spherical(X::CohSheaf)\n\nReturn the spherical structure isomorphism X → X∗∗.\n\n\n\n\n\n","category":"method"},{"location":"CoherentSheaves/#TensorCategories.stalks-Tuple{CohSheaf}","page":"Coherent Sheaves","title":"TensorCategories.stalks","text":"stalks(X::CohSheaf)\n\nReturn the stalks of X.\n\n\n\n\n\n","category":"method"},{"location":"CoherentSheaves/#TensorCategories.zero_morphism-Tuple{CohSheaf, CohSheaf}","page":"Coherent Sheaves","title":"TensorCategories.zero_morphism","text":"zero_morphism(X::CohSheaf, Y::CohSheaf)\n\nReturn the zero morphism 0:X → Y.\n\n\n\n\n\n","category":"method"},{"location":"CoherentSheaves/#Convolution-Category","page":"Coherent Sheaves","title":"Convolution Category","text":"","category":"section"},{"location":"CoherentSheaves/","page":"Coherent Sheaves","title":"Coherent Sheaves","text":"The objects of this category are again G-equivariant coherent sheaves on a finite G-set Xtimes X. But we endow them with a different monoidal product.","category":"page"},{"location":"CoherentSheaves/","page":"Coherent Sheaves","title":"Coherent Sheaves","text":"Let p_ij Xtimes Xtimes X to X times X be the canonical projections. Then we define the monoidal product of two coherent sheaves x and y","category":"page"},{"location":"CoherentSheaves/","page":"Coherent Sheaves","title":"Coherent Sheaves","text":"beginaligned\nxotimes y = p_13_ast(p_12^ast(x)otimes p_23^ast(y))\nendaligned","category":"page"},{"location":"CoherentSheaves/","page":"Coherent Sheaves","title":"Coherent Sheaves","text":"where otimesis the monoidal product of Coh(Xtimes Xtimes X). Similar for morphisms.","category":"page"},{"location":"CoherentSheaves/","page":"Coherent Sheaves","title":"Coherent Sheaves","text":"Objects in this category are of type","category":"page"},{"location":"CoherentSheaves/","page":"Coherent Sheaves","title":"Coherent Sheaves","text":"ConvolutionObject <: Object","category":"page"},{"location":"CoherentSheaves/","page":"Coherent Sheaves","title":"Coherent Sheaves","text":"while the convolution category is of type","category":"page"},{"location":"CoherentSheaves/","page":"Coherent Sheaves","title":"Coherent Sheaves","text":"ConvolutionCategory <: MultiTensorCategory","category":"page"},{"location":"CoherentSheaves/","page":"Coherent Sheaves","title":"Coherent Sheaves","text":"and can be constructed by","category":"page"},{"location":"CoherentSheaves/","page":"Coherent Sheaves","title":"Coherent Sheaves","text":"ConvolutionCategory","category":"page"},{"location":"CoherentSheaves/#TensorCategories.ConvolutionCategory","page":"Coherent Sheaves","title":"TensorCategories.ConvolutionCategory","text":"ConvolutionCategory(X::GSet, K::Field)\n\nReturn the category of equivariant coherent sheaves on X with convolution product.\n\n\n\n\n\nConvolutionCategory(X, K::Field)\n\nReturn the category of coherent sheaves on X with convolution product.\n\n\n\n\n\n","category":"type"},{"location":"CoherentSheaves/","page":"Coherent Sheaves","title":"Coherent Sheaves","text":"Morphisms are just morphisms of coherent sheaves with the new tensor product.","category":"page"},{"location":"CoherentSheaves/","page":"Coherent Sheaves","title":"Coherent Sheaves","text":"ConvolutionMorphism <: Morphism","category":"page"},{"location":"CoherentSheaves/","page":"Coherent Sheaves","title":"Coherent Sheaves","text":"Modules = [TensorCategories]\nPages = [\"ConvolutionCategory.jl\"]","category":"page"},{"location":"CoherentSheaves/#TensorCategories.ConvolutionCategory-Tuple{Any, AbstractAlgebra.Field}","page":"Coherent Sheaves","title":"TensorCategories.ConvolutionCategory","text":"ConvolutionCategory(X, K::Field)\n\nReturn the category of coherent sheaves on X with convolution product.\n\n\n\n\n\n","category":"method"},{"location":"CoherentSheaves/#TensorCategories.ConvolutionCategory-Tuple{GSet, AbstractAlgebra.Field}","page":"Coherent Sheaves","title":"TensorCategories.ConvolutionCategory","text":"ConvolutionCategory(X::GSet, K::Field)\n\nReturn the category of equivariant coherent sheaves on X with convolution product.\n\n\n\n\n\n","category":"method"},{"location":"CoherentSheaves/#AbstractAlgebra.isisomorphic-Tuple{ConvolutionObject, ConvolutionObject}","page":"Coherent Sheaves","title":"AbstractAlgebra.isisomorphic","text":"isisomorphic(X::ConvolutionObject, Y::ConvolutionObject)\n\nCheck whether Xand Yare isomorphic. Return the isomorphism if true.\n\n\n\n\n\n","category":"method"},{"location":"CoherentSheaves/#Base.one-Tuple{ConvolutionCategory}","page":"Coherent Sheaves","title":"Base.one","text":"one(C::ConvolutionCategory)\n\nReturn the one object in Conv(X).\n\n\n\n\n\n","category":"method"},{"location":"CoherentSheaves/#Base.zero-Tuple{ConvolutionCategory}","page":"Coherent Sheaves","title":"Base.zero","text":"zero(C::ConvolutionCategory)\n\nReturn the zero object in Conv(X).\n\n\n\n\n\n","category":"method"},{"location":"CoherentSheaves/#Hecke.decompose-Tuple{ConvolutionObject}","page":"Coherent Sheaves","title":"Hecke.decompose","text":"decompose(X::ConvolutionObject)\n\nDecompose X into a direct sum of simple objects with multiplicities.\n\n\n\n\n\n","category":"method"},{"location":"CoherentSheaves/#Hecke.tensor_product-Tuple{ConvolutionMorphism, ConvolutionMorphism}","page":"Coherent Sheaves","title":"Hecke.tensor_product","text":"tensor_product(f::ConvolutionMorphism, g::ConvolutionMorphism)\n\nReturn the convolution product of morphisms of coherent sheaves.\n\n\n\n\n\n","category":"method"},{"location":"CoherentSheaves/#Hecke.tensor_product-Tuple{ConvolutionObject, ConvolutionObject}","page":"Coherent Sheaves","title":"Hecke.tensor_product","text":"tensor_product(X::ConvolutionObject, Y::ConvolutionObject)\n\nReturn the convolution product of coherent sheaves.\n\n\n\n\n\n","category":"method"},{"location":"CoherentSheaves/#Oscar.issemisimple-Tuple{ConvolutionCategory}","page":"Coherent Sheaves","title":"Oscar.issemisimple","text":"issemisimple(C::ConvolutionCategory)\n\nCheck whether C semisimple.\n\n\n\n\n\n","category":"method"},{"location":"CoherentSheaves/#TensorCategories.Hom-Tuple{ConvolutionObject, ConvolutionObject}","page":"Coherent Sheaves","title":"TensorCategories.Hom","text":"Hom(X::ConvolutionObject, Y::ConvolutionObject)\n\nReturn Hom(XY) as a vector space.\n\n\n\n\n\n","category":"method"},{"location":"CoherentSheaves/#TensorCategories.dsum-2","page":"Coherent Sheaves","title":"TensorCategories.dsum","text":"dsum(X::ConvolutionObject, Y::ConvolutionObject, morphisms::Bool = false)\n\ndocumentation\n\n\n\n\n\n","category":"function"},{"location":"CoherentSheaves/#TensorCategories.dsum-Tuple{ConvolutionMorphism, ConvolutionMorphism}","page":"Coherent Sheaves","title":"TensorCategories.dsum","text":"dsum(f::ConvolutionMorphism, g::ConvolutionMorphism)\n\nReturn the direct sum of morphisms of coherent sheaves (with convolution product).\n\n\n\n\n\n","category":"method"},{"location":"CoherentSheaves/#TensorCategories.orbit_stabilizers-Tuple{ConvolutionCategory}","page":"Coherent Sheaves","title":"TensorCategories.orbit_stabilizers","text":"orbit_stabilizers(C::ConvolutionCategory)\n\nReturn the stabilizers of representatives of the orbits.\n\n\n\n\n\n","category":"method"},{"location":"CoherentSheaves/#TensorCategories.simples-Tuple{ConvolutionCategory}","page":"Coherent Sheaves","title":"TensorCategories.simples","text":"simples(C::ConvolutionCategory)\n\nReturn a list of simple objects in Conv(X).\n\n\n\n\n\n","category":"method"},{"location":"CoherentSheaves/#TensorCategories.stalks-Tuple{ConvolutionObject}","page":"Coherent Sheaves","title":"TensorCategories.stalks","text":"stalks(X::ConvolutionObject)\n\nReturn the stalks of the sheaf X.\n\n\n\n\n\n","category":"method"},{"location":"Center/#The-Center-Construction","page":"The Center Construction","title":"The Center Construction","text":"","category":"section"},{"location":"Center/","page":"The Center Construction","title":"The Center Construction","text":"Let Cbe a fusion category.  ","category":"page"},{"location":"Center/","page":"The Center Construction","title":"The Center Construction","text":"Modules = [TensorCategories]\nPages = [\"Center.jl\"]\nOrder = [:function]","category":"page"},{"location":"Center/#AbstractAlgebra.Generic.dim-Tuple{CenterObject}","page":"The Center Construction","title":"AbstractAlgebra.Generic.dim","text":"dim(X::CenterObject)\n\nReturn the categorical dimension of X.\n\n\n\n\n\n","category":"method"},{"location":"Center/#AbstractAlgebra.compose-Tuple{CenterMorphism, CenterMorphism}","page":"The Center Construction","title":"AbstractAlgebra.compose","text":"compose(f::CenterMorphism, g::CenterMorphism)\n\nReturn the composition g∘f.\n\n\n\n\n\n","category":"method"},{"location":"Center/#AbstractAlgebra.isisomorphic-Tuple{CenterObject, CenterObject}","page":"The Center Construction","title":"AbstractAlgebra.isisomorphic","text":"isisomorphic(X::CenterObject, Y::CenterObject)\n\nCheck if X≃Y. Return (true, m) where mis an isomorphism if true, else return (false,nothing).\n\n\n\n\n\n","category":"method"},{"location":"Center/#AbstractAlgebra.kernel-Tuple{CenterMorphism}","page":"The Center Construction","title":"AbstractAlgebra.kernel","text":"kernel(f::CenterMoprhism)\n\nReturn a tuple (K,k) where Kis the kernel object and kis the inclusion.\n\n\n\n\n\n","category":"method"},{"location":"Center/#Base.inv-Tuple{CenterMorphism}","page":"The Center Construction","title":"Base.inv","text":"inv(f::CenterMorphism)\n\nReturn the inverse of fif possible.\n\n\n\n\n\n","category":"method"},{"location":"Center/#Base.one-Tuple{CenterCategory}","page":"The Center Construction","title":"Base.one","text":"one(C::CenterCategory)\n\nReturn the one object of C.\n\n\n\n\n\n","category":"method"},{"location":"Center/#Base.zero-Tuple{CenterCategory}","page":"The Center Construction","title":"Base.zero","text":"zero(C::CenterCategory)\n\nReturn the zero object of C.\n\n\n\n\n\n","category":"method"},{"location":"Center/#Hecke.cokernel-Tuple{CenterMorphism}","page":"The Center Construction","title":"Hecke.cokernel","text":"cokernel(f::CenterMorphism)\n\nReturn a tuple (C,c) where Cis the cokernel object and cis the projection.\n\n\n\n\n\n","category":"method"},{"location":"Center/#Hecke.dual-Tuple{CenterObject}","page":"The Center Construction","title":"Hecke.dual","text":"dual(X::CenterObject)\n\nReturn the (left) dual object of X.\n\n\n\n\n\n","category":"method"},{"location":"Center/#Hecke.id-Tuple{CenterObject}","page":"The Center Construction","title":"Hecke.id","text":"id(X::CenterObject)\n\nReturn the identity on X.\n\n\n\n\n\n","category":"method"},{"location":"Center/#Hecke.is_central","page":"The Center Construction","title":"Hecke.is_central","text":"is_central(Z::Object)\n\nReturn true if Z is in the categorical center, i.e. there exists a half-braiding on Z.\n\n\n\n\n\n","category":"function"},{"location":"Center/#Hecke.tensor_product-Tuple{CenterMorphism, CenterMorphism}","page":"The Center Construction","title":"Hecke.tensor_product","text":"tensor_product(f::CenterMorphism,g::CenterMorphism)\n\nReturn the tensor product of f and g.\n\n\n\n\n\n","category":"method"},{"location":"Center/#Hecke.tensor_product-Tuple{CenterObject, CenterObject}","page":"The Center Construction","title":"Hecke.tensor_product","text":"tensor_product(X::CenterObject, Y::CenterObject)\n\nReturn the tensor product of X and Y.\n\n\n\n\n\n","category":"method"},{"location":"Center/#LinearAlgebra.tr-Tuple{CenterMorphism}","page":"The Center Construction","title":"LinearAlgebra.tr","text":"tr(f:::CenterMorphism)\n\nReturn the categorical trace of f.\n\n\n\n\n\n","category":"method"},{"location":"Center/#TensorCategories.Center-Tuple{Category}","page":"The Center Construction","title":"TensorCategories.Center","text":"Center(C::Category)\n\nReturn the Drinfeld center of C.\n\n\n\n\n\n","category":"method"},{"location":"Center/#TensorCategories.add_simple!-Tuple{CenterCategory, CenterObject}","page":"The Center Construction","title":"TensorCategories.add_simple!","text":"add_simple!(C::CenterCategory, S::CenterObject)\n\nAdd the simple object S to the vector of simple objects.\n\n\n\n\n\n","category":"method"},{"location":"Center/#TensorCategories.associator-Tuple{CenterObject, CenterObject, CenterObject}","page":"The Center Construction","title":"TensorCategories.associator","text":"associator(X::CenterObject, Y::CenterObject, Z::CenterObject)\n\nReturn the associator isomorphism (X⊗Y)⊗Z → X⊗(Y⊗Z).\n\n\n\n\n\n","category":"method"},{"location":"Center/#TensorCategories.braiding-Tuple{CenterObject, CenterObject}","page":"The Center Construction","title":"TensorCategories.braiding","text":"braiding(X::CenterObject, Y::CenterObject)\n\nReturn the braiding isomorphism X⊗Y → Y⊗X.\n\n\n\n\n\n","category":"method"},{"location":"Center/#TensorCategories.coev-Tuple{CenterObject}","page":"The Center Construction","title":"TensorCategories.coev","text":"coev(X::CenterObject)\n\nReturn the coevaluation morphism 1 → X⊗X∗.\n\n\n\n\n\n","category":"method"},{"location":"Center/#TensorCategories.dsum-Tuple{CenterMorphism, CenterMorphism}","page":"The Center Construction","title":"TensorCategories.dsum","text":"dsum(f::CenterMorphism, g::CenterMorphism)\n\nReturn the direct sum of f and g.\n\n\n\n\n\n","category":"method"},{"location":"Center/#TensorCategories.dsum-Tuple{CenterObject, CenterObject}","page":"The Center Construction","title":"TensorCategories.dsum","text":"dsum(X::CenterObject, Y::CenterObject)\n\nReturn the direct sum object of X and Y.\n\n\n\n\n\n","category":"method"},{"location":"Center/#TensorCategories.ev-Tuple{CenterObject}","page":"The Center Construction","title":"TensorCategories.ev","text":"ev(X::CenterObject)\n\nReturn the evaluation morphism X⊗X → 1.\n\n\n\n\n\n","category":"method"},{"location":"Center/#TensorCategories.half_braiding-Tuple{CenterObject}","page":"The Center Construction","title":"TensorCategories.half_braiding","text":"half_braiding(Z::CenterObject)\n\nReturn  a vector with half braiding morphisms Z⊗S → S⊗Z for all simple objects S.\n\n\n\n\n\n","category":"method"},{"location":"Center/#TensorCategories.half_braidings-Tuple{Object}","page":"The Center Construction","title":"TensorCategories.half_braidings","text":"half_braidings(Z::Object)\n\nReturn all objects in the center lying over Z.\n\n\n\n\n\n","category":"method"},{"location":"Center/#TensorCategories.object-Tuple{CenterObject}","page":"The Center Construction","title":"TensorCategories.object","text":"object(X::CenterObject)\n\nReturn the onderlying object in 𝒞.\n\n\n\n\n\n","category":"method"},{"location":"Center/#TensorCategories.simples-Tuple{CenterCategory}","page":"The Center Construction","title":"TensorCategories.simples","text":"simples(C::CenterCategory)\n\nReturn a vector containing the simple objects of C. The list might be incomplete.\n\n\n\n\n\n","category":"method"},{"location":"Center/#TensorCategories.spherical-Tuple{CenterObject}","page":"The Center Construction","title":"TensorCategories.spherical","text":"spherical(X::CenterObject)\n\nReturn the spherical structure X → X∗∗ of X.\n\n\n\n\n\n","category":"method"},{"location":"Center/#TensorCategories.zero_morphism-Tuple{CenterObject, CenterObject}","page":"The Center Construction","title":"TensorCategories.zero_morphism","text":"zero_morphism(X::CenterObject, Y::CenterObject)\n\nReturn the zero morphism 0:X → Y.\n\n\n\n\n\n","category":"method"},{"location":"Representations/","page":"Representations","title":"Representations","text":"CurrentModule = TensorCategories","category":"page"},{"location":"Representations/#Representations","page":"Representations","title":"Representations","text":"","category":"section"},{"location":"Representations/","page":"Representations","title":"Representations","text":"We provide a simple abstract type hierarchy for representation categories:","category":"page"},{"location":"Representations/","page":"Representations","title":"Representations","text":"abstract type RepresentationCategory <:Category","category":"page"},{"location":"Representations/","page":"Representations","title":"Representations","text":"A representation category always requires the field","category":"page"},{"location":"Representations/","page":"Representations","title":"Representations","text":"base_ring::Field","category":"page"},{"location":"Representations/#Representations-of-Finite-groups","page":"Representations","title":"Representations of Finite groups","text":"","category":"section"},{"location":"Representations/","page":"Representations","title":"Representations","text":"Let G be a finite group. We consider the category of finite dimensional k-representations of G.","category":"page"},{"location":"Representations/","page":"Representations","title":"Representations","text":"GroupRepresentationCategory <: RepresentationCategory","category":"page"},{"location":"Representations/","page":"Representations","title":"Representations","text":"Build it with the constructor","category":"page"},{"location":"Representations/","page":"Representations","title":"Representations","text":"RepresentationCategory(::GAPGroup, ::Field)","category":"page"},{"location":"Representations/#TensorCategories.RepresentationCategory-Tuple{Oscar.GAPGroup, AbstractAlgebra.Field}","page":"Representations","title":"TensorCategories.RepresentationCategory","text":"RepresentationCategory(G::GAPGroup, F::Field)\n\nCategory of finite dimensonal group representations of \\G.\n\n\n\n\n\n","category":"method"},{"location":"Representations/","page":"Representations","title":"Representations","text":"A group representation is defined by a group homomorphism from G into a finite dimensional vector space k^n. These objects are of type","category":"page"},{"location":"Representations/","page":"Representations","title":"Representations","text":"GroupRepresentation <: Representation","category":"page"},{"location":"Representations/","page":"Representations","title":"Representations","text":"They are constructed in one of two ways, either by images of generators or by a function","category":"page"},{"location":"Representations/","page":"Representations","title":"Representations","text":"Representation(::GAPGroup,::Vector,::Vector)\nRepresentation(::GAPGroup,::Function)","category":"page"},{"location":"Representations/#TensorCategories.Representation-Tuple{Oscar.GAPGroup, Vector{T} where T, Vector{T} where T}","page":"Representations","title":"TensorCategories.Representation","text":"Representation(G::GAPGroup, pre_img::Vector, img::Vector)\n\nGroup representation defined by the images of generators of G.\n\n\n\n\n\n","category":"method"},{"location":"Representations/#TensorCategories.Representation-Tuple{Oscar.GAPGroup, Function}","page":"Representations","title":"TensorCategories.Representation","text":"Representation(G::GAPGroup, m::Function)\n\nGroup representation defined by m:G -> Mat_n.\n\n\n\n\n\n","category":"method"},{"location":"Representations/","page":"Representations","title":"Representations","text":"where in both cases the images are required to be fitting MatrixElem objects.","category":"page"},{"location":"Representations/","page":"Representations","title":"Representations","text":"Since group representation categories are tensor categories, we again have methods for the important operations","category":"page"},{"location":"Representations/","page":"Representations","title":"Representations","text":"Modules = [TensorCategories]\nPages = [\"GroupRepresentations.jl\"]","category":"page"},{"location":"Representations/#TensorCategories.Morphism-Tuple{GroupRepresentation, GroupRepresentation, MatElem}","page":"Representations","title":"TensorCategories.Morphism","text":"Morphism(ρ::GroupRepresentation, τ::GroupRepresentation, m::MatElem; check = true)\n\nMorphism between representations defined by m. If check == false equivariancy will not be checked.\n\n\n\n\n\n","category":"method"},{"location":"Representations/#AbstractAlgebra.isisomorphic-Tuple{GroupRepresentation, GroupRepresentation}","page":"Representations","title":"AbstractAlgebra.isisomorphic","text":"isisomorphic(σ::GroupRepresentation, τ::GroupRepresentation)\n\nCheck whether σ and τ are isomorphic. If true return the isomorphism.\n\n\n\n\n\n","category":"method"},{"location":"Representations/#Base.one-Tuple{GroupRepresentationCategory}","page":"Representations","title":"Base.one","text":"one(Rep::GroupRepresentationCategory)\n\nReturn the trivial representation.\n\n\n\n\n\n","category":"method"},{"location":"Representations/#Base.parent-Tuple{GroupRepresentation}","page":"Representations","title":"Base.parent","text":"parent(ρ::GroupRepresentation)\n\nReturn the parent representation category of ρ.\n\n\n\n\n\n","category":"method"},{"location":"Representations/#Base.zero-Tuple{GroupRepresentationCategory}","page":"Representations","title":"Base.zero","text":"zero(Rep::GroupRepresentationCategory)\n\nReturn the zero reprensentation.\n\n\n\n\n\n","category":"method"},{"location":"Representations/#Hecke.decompose-Tuple{GroupRepresentation}","page":"Representations","title":"Hecke.decompose","text":"decompose(σ::GroupRepresentation)\n\nDecompose the representation into a direct sum of simple objects. Return a list of tuples with simple objects and multiplicities.\n\n\n\n\n\n","category":"method"},{"location":"Representations/#Hecke.id-Tuple{GroupRepresentation}","page":"Representations","title":"Hecke.id","text":"id(ρ::GroupRepresentation)\n\nReturn the identity on ρ.\n\n\n\n\n\n","category":"method"},{"location":"Representations/#Hecke.tensor_product-Tuple{GroupRepresentation, GroupRepresentation}","page":"Representations","title":"Hecke.tensor_product","text":"tensor_product(ρ::GroupRepresentation, τ::GroupRepresentation)\n\nReturn the tensor product of representations.\n\n\n\n\n\n","category":"method"},{"location":"Representations/#Hecke.tensor_product-Tuple{GroupRepresentationMorphism, GroupRepresentationMorphism}","page":"Representations","title":"Hecke.tensor_product","text":"tensor_product(f::GroupRepresentationMorphism, g::GroupRepresentationMorphism)\n\nReturn the tensor product of morphisms of representations.\n\n\n\n\n\n","category":"method"},{"location":"Representations/#Oscar.issemisimple-Tuple{GroupRepresentationCategory}","page":"Representations","title":"Oscar.issemisimple","text":"issemisimple(C::GroupRepresentationCategory)\n\nReturn true if C is semisimple else false.\n\n\n\n\n\n","category":"method"},{"location":"Representations/#TensorCategories.Hom-Tuple{GroupRepresentation, GroupRepresentation}","page":"Representations","title":"TensorCategories.Hom","text":"Hom(σ::GroupRepresentation, τ::GroupRepresentation)\n\nReturn the hom-space of the representations as a vector space.\n\n\n\n\n\n","category":"method"},{"location":"Representations/#TensorCategories.dsum","page":"Representations","title":"TensorCategories.dsum","text":"dsum(ρ::GroupRepresentation, τ::GroupRepresentation, morphisms::Bool = false)\n\nReturn the direct sum of representations. If morphisms is set true inclusion and projection morphisms are also returned.\n\n\n\n\n\n","category":"function"},{"location":"Representations/#TensorCategories.dsum-Tuple{GroupRepresentationMorphism, GroupRepresentationMorphism}","page":"Representations","title":"TensorCategories.dsum","text":"dsum(f::GroupRepresentationMorphism, g::GroupRepresentationMorphism)\n\nDirect sum of morphisms of representations.\n\n\n\n\n\n","category":"method"},{"location":"Representations/#TensorCategories.simples-Tuple{GroupRepresentationCategory}","page":"Representations","title":"TensorCategories.simples","text":"simples(Rep::GroupRepresentationCategory)\n\nReturn a list of the simple objects in Rep.\n\n\n\n\n\n","category":"method"},{"location":"Multitensor/#Multitensor-Categories","page":"Multitensor Category Interface","title":"Multitensor Categories","text":"","category":"section"},{"location":"Multitensor/","page":"Multitensor Category Interface","title":"Multitensor Category Interface","text":"The main idea of TensorCategories is to provide abstract methods for categorical computations in (multi)tensor, respectively (multi)fusion categories. To use this framework with custom structs implementing such a category one has to follow some rules.","category":"page"},{"location":"Multitensor/#Necessities","page":"Multitensor Category Interface","title":"Necessities","text":"","category":"section"},{"location":"Multitensor/","page":"Multitensor Category Interface","title":"Multitensor Category Interface","text":"For basic functionality of YourCategory <: Category together with Objects YourObject <: Object and morphisms YourMorphism <: Morphism you have to minimally build","category":"page"},{"location":"Multitensor/","page":"Multitensor Category Interface","title":"Multitensor Category Interface","text":"struct YourCategory <: Category\n  base_ring::Field\nend\n\nstruct YourObject <: Object\n  parent::YourCategory\nend\n\nstruct YourMorphism <: Morphism\n  domain::YourObject\n  codomain::YourObject\nend","category":"page"},{"location":"Multitensor/","page":"Multitensor Category Interface","title":"Multitensor Category Interface","text":"For objects you need to provide the following methods:","category":"page"},{"location":"Multitensor/","page":"Multitensor Category Interface","title":"Multitensor Category Interface","text":"dsum(X::YourObject, Y::YourObject) ::YourObject\ntensor_product(X::YourObject, Y::YourObject) ::YourObject\nid(X::YourObject) ::YourMorphism","category":"page"},{"location":"Multitensor/","page":"Multitensor Category Interface","title":"Multitensor Category Interface","text":"For morphisms you need","category":"page"},{"location":"Multitensor/","page":"Multitensor Category Interface","title":"Multitensor Category Interface","text":"dsum(f::YourMorphism, g::YourMorphism) ::YourMorphism\ntensor_product(f::YourMorphism, g::YourMorphism) ::YourMorphism\ncompose(f::YourMorphism, g::YourMorphism) ::YourMorphism","category":"page"},{"location":"Multitensor/","page":"Multitensor Category Interface","title":"Multitensor Category Interface","text":"Last you should give constructors for the one and zero","category":"page"},{"location":"Multitensor/","page":"Multitensor Category Interface","title":"Multitensor Category Interface","text":"one(C::YourCategory) ::YourObject\nzero(C::YourCategory) ::YourObject","category":"page"},{"location":"Multitensor/#Groethendieck-Ring","page":"Multitensor Category Interface","title":"Groethendieck Ring","text":"","category":"section"},{"location":"Multitensor/","page":"Multitensor Category Interface","title":"Multitensor Category Interface","text":"TensorCategories can compute the Groethendieck ring of a semisimple multitensor category, if provided with methods","category":"page"},{"location":"Multitensor/","page":"Multitensor Category Interface","title":"Multitensor Category Interface","text":"# Return the simple objects\nsimples(C::YourCategory) ::Vector{YourObject}\n\n# Decompose into simple summands with multiplicity\ndecompose(X::YourObject) ::Vector{Tuple{YourObject, Int}}\n\n# Check for isomorphy\nisisomorphic(X::YourObject, Y::YourObject) ::Tuple{Bool, Union{YourMorphism, Nothing}}","category":"page"},{"location":"Multitensor/","page":"Multitensor Category Interface","title":"Multitensor Category Interface","text":"Provided these methods exist you can call the function grothendieck_ring on your category.","category":"page"},{"location":"Multitensor/","page":"Multitensor Category Interface","title":"Multitensor Category Interface","text":"grothendieck_ring","category":"page"},{"location":"Multitensor/#TensorCategories.grothendieck_ring","page":"Multitensor Category Interface","title":"TensorCategories.grothendieck_ring","text":"grothendieck_ring(C::Category)\n\nReturn the grothendieck ring of the multiring category C.\n\n\n\n\n\n","category":"function"},{"location":"Multitensor/","page":"Multitensor Category Interface","title":"Multitensor Category Interface","text":"Since this is a generic methods it is by nature not the fastest. Thus if you know more about your category you should specify grothendieck_ring on your type manually.","category":"page"},{"location":"Multitensor/#Example","page":"Multitensor Category Interface","title":"Example","text":"","category":"section"},{"location":"Multitensor/","page":"Multitensor Category Interface","title":"Multitensor Category Interface","text":"Take a look at the convolution category:","category":"page"},{"location":"Multitensor/","page":"Multitensor Category Interface","title":"Multitensor Category Interface","text":"using TensorCategories, Oscar","category":"page"},{"location":"Multitensor/","page":"Multitensor Category Interface","title":"Multitensor Category Interface","text":"G = symmetric_group(2)\nX = gset(G, [1,2,3])\nF,_ = FiniteField(5)\nConv = ConvolutionCategory(X,F)\n\nR,f = grothendieck_ring(Conv)","category":"page"},{"location":"Multitensor/#The-S-Matrix","page":"Multitensor Category Interface","title":"The S-Matrix","text":"","category":"section"},{"location":"Multitensor/","page":"Multitensor Category Interface","title":"Multitensor Category Interface","text":"For a braided fusion category with spherical structure and simple objects X_i the S-matrix is defined as","category":"page"},{"location":"Multitensor/","page":"Multitensor Category Interface","title":"Multitensor Category Interface","text":"beginaligned\n(S)_ij = Tr(c_X_iX_j circ c_X_jX_i)\nendaligned","category":"page"},{"location":"Multitensor/","page":"Multitensor Category Interface","title":"Multitensor Category Interface","text":"Hence you see you need to provide a trace function and a braiding. The braiding","category":"page"},{"location":"Multitensor/","page":"Multitensor Category Interface","title":"Multitensor Category Interface","text":"braiding(X::YourObject, Y::YourObject) ::YourMorphism","category":"page"},{"location":"Multitensor/","page":"Multitensor Category Interface","title":"Multitensor Category Interface","text":"There are two ways to archive the trace: either you provide the trace by yourself","category":"page"},{"location":"Multitensor/","page":"Multitensor Category Interface","title":"Multitensor Category Interface","text":"tr(f::YourMorphism) ::YourMorphism","category":"page"},{"location":"Multitensor/","page":"Multitensor Category Interface","title":"Multitensor Category Interface","text":"or you provide a spherical structure, duals, evaluation and coevaluation","category":"page"},{"location":"Multitensor/","page":"Multitensor Category Interface","title":"Multitensor Category Interface","text":"spherical(X::YourObject) ::YourMorphism\ndual(X::YourObject) ::YourObject\nev(X::YourObject) ::YourMorphism\ncoev(X::YourObject) ::YourMorphism","category":"page"},{"location":"Multitensor/","page":"Multitensor Category Interface","title":"Multitensor Category Interface","text":"with which the generic left categorical trace will be computed.","category":"page"},{"location":"Multitensor/","page":"Multitensor Category Interface","title":"Multitensor Category Interface","text":"tr","category":"page"},{"location":"Multitensor/#LinearAlgebra.tr","page":"Multitensor Category Interface","title":"LinearAlgebra.tr","text":"tr(f:::CenterMorphism)\n\nReturn the categorical trace of f.\n\n\n\n\n\n","category":"function"},{"location":"Multitensor/#Example-2","page":"Multitensor Category Interface","title":"Example","text":"","category":"section"},{"location":"Multitensor/","page":"Multitensor Category Interface","title":"Multitensor Category Interface","text":"We can compute now the S-matrix of for the representations.","category":"page"},{"location":"Multitensor/","page":"Multitensor Category Interface","title":"Multitensor Category Interface","text":"G = symmetric_group(3)\nF,_ = FiniteField(5)\nRep = RepresentationCategory(G,F)\n\nsmatrix(Rep)","category":"page"},{"location":"RingCatExamples/#Tambara-Yamagami-Fusion-Categories","page":"Examples","title":"Tambara Yamagami Fusion Categories","text":"","category":"section"},{"location":"RingCatExamples/","page":"Examples","title":"Examples","text":"For a detailed intrutuction to Tambara-Yamagami categories we refer to TY.","category":"page"},{"location":"RingCatExamples/","page":"Examples","title":"Examples","text":"Let A be a finite abelian group with n elements. The Tambara-Yamagami fusion category TY_A has n+1 simple objects of which n are invertible. We denote the simple objects by a_1a_nin A and m. The monoidal product is given by a_i otimes a_j = a_icdot a_j, a_i otimes m = m otimes a_i = m and m otimes m = a_1 oplus cdots oplus a_n. ","category":"page"},{"location":"RingCategory/","page":"Idea","title":"Idea","text":"using TensorCategories, Oscar","category":"page"},{"location":"RingCategory/#Semisimple-Ring-Categories-from-6j-Symbols","page":"Idea","title":"Semisimple Ring Categories from 6j-Symbols","text":"","category":"section"},{"location":"RingCategory/","page":"Idea","title":"Idea","text":"We provide a structure RingCategory for finite semisimple skeletal (multi)ring categories. ","category":"page"},{"location":"RingCategory/","page":"Idea","title":"Idea","text":"They are constructed by setting the multiplication table for the monoidal product and associativity for the simple objects. Objects in finite semisimple ring categories are just vectors with multiplicities of the simple objects in the decomposition. Thus morphism are vectors of matrices of according size.","category":"page"},{"location":"RingCategory/","page":"Idea","title":"Idea","text":"As an example we will construct the Ising fusion category. This is a fusion category with three simple objects 1, chi and X. The multiplication is given by chi otimes chi = 1, chi otimes X = X otimes chi and X otimes X = 1 oplus chi. There are precisely 3 non-trivial 6j-symbols Phi_X^chiXchi = -1, Phi_chi^XchiX = -1 und Phi_X^XXX = frac1sqrt 2beginpmatrix 1  1  1  -1endpmatrix.","category":"page"},{"location":"RingCategory/","page":"Idea","title":"Idea","text":"F = QQBar\nI = RingCategory(F,[\"𝟙\", \"χ\", \"X\"])\n\nM = zeros(Int,3,3,3)\n\nM[1,1,:] = [1,0,0]\nM[1,2,:] = [0,1,0]\nM[1,3,:] = [0,0,1]\nM[2,1,:] = [0,1,0]\nM[2,2,:] = [1,0,0]\nM[2,3,:] = [0,0,1]\nM[3,1,:] = [0,0,1]\nM[3,2,:] = [0,0,1]\nM[3,3,:] = [1,1,0]\n\nset_tensor_product!(I,M)\n\nset_associator!(I, 2,3,2,3, [-1])\nset_associator!(I, 3,2,3,2, [-1])\nset_associator!(I, 3,3,3,3, inv(sqrt(F(2))).*[1 1; 1 -1])","category":"page"},{"location":"RingCategory/","page":"Idea","title":"Idea","text":"At the current state of development the unit object has to be set manually. Other structure like spherical structures are set as identities, which might or might not be correct. It is also possible to set a braiding.","category":"page"},{"location":"RingCategory/","page":"Idea","title":"Idea","text":"set_one!(I, [1,0,0])\n\n#set one of four possible braidings \nα = root_of_unity(F,8)\n\nbraid = Array{MatElem,3}(undef, 3,3,3)\n\nbraid[1,1,:] = matrices(id(I[1]))\nbraid[1,2,:] = braid[2,1,:] = matrices(id(I[2]))\nbraid[2,2,:] = -1 .* matrices(id(I[1]))\n\nbraid[1,3,:] = braid[3,1,:] = matrices(id(I[3]))\nbraid[2,3,:] = braid[3,2,:] = α^2 .* matrices(id(I[3]))\n\nbraid[3,3,:] = matrices((α * id(I[1]) ⊕ (α^7 * id(I[2]))))\n\nset_braiding!(I,braid)\n\n# Check the pentagon equations for all simple objects in I\n@show pentagon_axiom(I)","category":"page"},{"location":"VectorSpaces/","page":"Vector Spaces","title":"Vector Spaces","text":"using TensorCategories, Oscar","category":"page"},{"location":"VectorSpaces/#Vector-Space-Categories","page":"Vector Spaces","title":"Vector Space Categories","text":"","category":"section"},{"location":"VectorSpaces/","page":"Vector Spaces","title":"Vector Spaces","text":"Vector spaces in TensorCategories are of the abstract type","category":"page"},{"location":"VectorSpaces/","page":"Vector Spaces","title":"Vector Spaces","text":"abstract type VectorSpaceObject{T} <: Object end","category":"page"},{"location":"VectorSpaces/","page":"Vector Spaces","title":"Vector Spaces","text":"All objects with vector space structure like hom-spaces are and should be implemented as a subtype of this type. They always need the following fields:","category":"page"},{"location":"VectorSpaces/","page":"Vector Spaces","title":"Vector Spaces","text":"basis::Vector{Any}\nparent::Category","category":"page"},{"location":"VectorSpaces/#Finite-Dimensional-VectorSpaces","page":"Vector Spaces","title":"Finite Dimensional VectorSpaces","text":"","category":"section"},{"location":"VectorSpaces/","page":"Vector Spaces","title":"Vector Spaces","text":"The simplest example to provide are the finite dimensional vector spaces over a field. This category has type","category":"page"},{"location":"VectorSpaces/","page":"Vector Spaces","title":"Vector Spaces","text":"VectorSpaces <: TensorCategory","category":"page"},{"location":"VectorSpaces/","page":"Vector Spaces","title":"Vector Spaces","text":"and can be constructed like so:","category":"page"},{"location":"VectorSpaces/","page":"Vector Spaces","title":"Vector Spaces","text":"F,a = FiniteField(5,2)\nVec = VectorSpaces(F)","category":"page"},{"location":"VectorSpaces/","page":"Vector Spaces","title":"Vector Spaces","text":"Objects of this category are of the type","category":"page"},{"location":"VectorSpaces/","page":"Vector Spaces","title":"Vector Spaces","text":"VSObject <: VectorSpaceObject","category":"page"},{"location":"VectorSpaces/","page":"Vector Spaces","title":"Vector Spaces","text":"Every vector space object is defined by a basis and a base field provided by the parent category.","category":"page"},{"location":"VectorSpaces/","page":"Vector Spaces","title":"Vector Spaces","text":"VectorSpaceObject\nVectorSpaceObject(::VectorSpaces,::Int)","category":"page"},{"location":"VectorSpaces/#TensorCategories.VectorSpaceObject","page":"Vector Spaces","title":"TensorCategories.VectorSpaceObject","text":"VectorSpaceObject\n\nAn object in the category of finite dimensional vector spaces.\n\n\n\n\n\n","category":"type"},{"location":"VectorSpaces/#TensorCategories.VectorSpaceObject-Tuple{VectorSpaces, Int64}","page":"Vector Spaces","title":"TensorCategories.VectorSpaceObject","text":"VectorSpaceObject(Vec::VectorSpaces, n::Int64)\nVectorSpaceObject(K::Field, n::Int)\nVectorSpaceObject(Vec::VectorSpaces, basis::Vector)\nVectorSpaceObject(K::Field, basis::Vector)\n\nThe n-dimensional vector space with basis v1,..,vn (or other specified basis)\n\n\n\n\n\n","category":"method"},{"location":"VectorSpaces/","page":"Vector Spaces","title":"Vector Spaces","text":"Morphisms in this Category are defined only by matrices of matching dimensions. They are typed as","category":"page"},{"location":"VectorSpaces/","page":"Vector Spaces","title":"Vector Spaces","text":"VSMorphism <: Morphism","category":"page"},{"location":"VectorSpaces/","page":"Vector Spaces","title":"Vector Spaces","text":"and constructed giving a domain, codomain and matrix element.","category":"page"},{"location":"VectorSpaces/","page":"Vector Spaces","title":"Vector Spaces","text":"Morphism(::VectorSpaceObject, ::VectorSpaceObject, ::MatElem)","category":"page"},{"location":"VectorSpaces/#Graded-Vector-Spaces","page":"Vector Spaces","title":"Graded Vector Spaces","text":"","category":"section"},{"location":"VectorSpaces/","page":"Vector Spaces","title":"Vector Spaces","text":"Very similar we have the category of finite dimensional (twisted) G-graded vector spaces for a finite group G. We have the type","category":"page"},{"location":"VectorSpaces/","page":"Vector Spaces","title":"Vector Spaces","text":"GradedVectorSpaces <: VectorSpaces","category":"page"},{"location":"VectorSpaces/","page":"Vector Spaces","title":"Vector Spaces","text":"and they are constructed in straightforward manner","category":"page"},{"location":"VectorSpaces/","page":"Vector Spaces","title":"Vector Spaces","text":"G = symmetric_group(6)\nF,a = FiniteField(2,3)\nVecG = GradedVectorSpaces(F,G)","category":"page"},{"location":"VectorSpaces/","page":"Vector Spaces","title":"Vector Spaces","text":"To add a nontrivial associator (twist) construct a Cocycle{3} object coding a 3-cocycle of the group G. By now no checking of this condition happens.","category":"page"},{"location":"VectorSpaces/","page":"Vector Spaces","title":"Vector Spaces","text":"function cyclic_group_3cocycle(G, F, ξ)\n\tg = G[1]\n\tn = order(G)\n\tD = Dict((g^i,g^j,g^k) => ξ^(div(i*(j+k - rem(j+k,n)),n)) for i ∈ 0:n-1, j ∈ 0:n-1, k ∈ 0:n-1)\n\treturn Cocycle(G,D)\nend\n\nF,ξ = CyclotomicField(5, \"ξ\")\nc = cyclic_group_3cocycle(G,F,ξ)\nVecG = GradedVectorSpaces(F,G,c)","category":"page"},{"location":"VectorSpaces/","page":"Vector Spaces","title":"Vector Spaces","text":"Graded vector spaces decompose into direct sums of vector spaces for each element in G.","category":"page"},{"location":"VectorSpaces/","page":"Vector Spaces","title":"Vector Spaces","text":"GVSObject <: VectorSpaceObject","category":"page"},{"location":"VectorSpaces/","page":"Vector Spaces","title":"Vector Spaces","text":"G = symmetric_group(5)\ng,s = gens(G)\nV1 = VectorSpaceObject(QQ,5)\nV2 = VectorSpaceObject(QQ, [:v, :w])\nW = VectorSpaceObject(g => V1, s => V2, g*s => V1⊗V2)","category":"page"},{"location":"VectorSpaces/","page":"Vector Spaces","title":"Vector Spaces","text":"Morphisms are implemented analogously by pairs of group elements and vector space objects.","category":"page"},{"location":"VectorSpaces/","page":"Vector Spaces","title":"Vector Spaces","text":"GVSMorphism <: Morphism","category":"page"},{"location":"VectorSpaces/","page":"Vector Spaces","title":"Vector Spaces","text":"The constructor is given by ","category":"page"},{"location":"VectorSpaces/","page":"Vector Spaces","title":"Vector Spaces","text":"Morphism(::GVSObject, ::GVSObject,::MatElem) where {G, S <: VectorSpaceMorphism}","category":"page"},{"location":"VectorSpaces/#Functionality","page":"Vector Spaces","title":"Functionality","text":"","category":"section"},{"location":"VectorSpaces/","page":"Vector Spaces","title":"Vector Spaces","text":"(Graded) vector spaces form a fusion category. Thus the methods for direct sums, tensor products, dual, one and zero object are all implemented.","category":"page"},{"location":"VectorSpaces/","page":"Vector Spaces","title":"Vector Spaces","text":"Modules = [TensorCategories]\nPages = [\"VectorSpaces.jl\"]\nOrder = [:function]","category":"page"},{"location":"VectorSpaces/#AbstractAlgebra.Generic.dim-Tuple{VectorSpaceObject}","page":"Vector Spaces","title":"AbstractAlgebra.Generic.dim","text":"dim(V::VectorSpaceObject) = length(V.basis)\n\nReturn the vector space dimension of V.\n\n\n\n\n\n","category":"method"},{"location":"VectorSpaces/#AbstractAlgebra.isisomorphic-Tuple{GVSObject, GVSObject}","page":"Vector Spaces","title":"AbstractAlgebra.isisomorphic","text":"function isisomorphic(V::GVSObject, W::GVSObject)\n\nCheck whether Vand Ware isomorphic as G-graded vector spaces and return an isomorphism in the positive case.\n\n\n\n\n\n","category":"method"},{"location":"VectorSpaces/#AbstractAlgebra.isisomorphic-Tuple{VectorSpaceObject, VectorSpaceObject}","page":"Vector Spaces","title":"AbstractAlgebra.isisomorphic","text":"isisomorphic(V::VSObject, W::VSObject)\n\nCheck whether V and Ware isomorphic. Return the isomorphisms if existent.\n\n\n\n\n\n","category":"method"},{"location":"VectorSpaces/#AbstractAlgebra.kernel-Tuple{GVSMorphism}","page":"Vector Spaces","title":"AbstractAlgebra.kernel","text":"function kernel(f::GVSMorphism)\n\nReturn the graded vector space kernel of f.\n\n\n\n\n\n","category":"method"},{"location":"VectorSpaces/#Base.one-Tuple{GradedVectorSpaces}","page":"Vector Spaces","title":"Base.one","text":"function one(C::GradedVectorSpaces)\n\nReturn ´´k´´ as the one dimensional graded vector space.\n\n\n\n\n\n","category":"method"},{"location":"VectorSpaces/#Base.one-Tuple{VectorSpaces}","page":"Vector Spaces","title":"Base.one","text":"one(Vec::VectorSpaces) = VectorSpaceObject(base_ring(Vec),1)\n\nReturn the one-dimensional vector space.\n\n\n\n\n\n","category":"method"},{"location":"VectorSpaces/#Base.zero-Tuple{GradedVectorSpaces}","page":"Vector Spaces","title":"Base.zero","text":"function zero(C::GradedVectorSpaces)\n\nReturn the zero diemsnional graded vector space.\n\n\n\n\n\n","category":"method"},{"location":"VectorSpaces/#Base.zero-Tuple{VectorSpaces}","page":"Vector Spaces","title":"Base.zero","text":"zero(Vec::VectorSpaces) = VectorSpaceObject(base_ring(Vec), 0)\n\nReturn the zero-dimensional vector space.\n\n\n\n\n\n","category":"method"},{"location":"VectorSpaces/#Hecke.cokernel-Tuple{GVSMorphism}","page":"Vector Spaces","title":"Hecke.cokernel","text":"function cokernel(f::GVSMorphism)\n\nReturn the graded vector space cokernel of f.\n\n\n\n\n\n","category":"method"},{"location":"VectorSpaces/#Hecke.decompose-Tuple{GVSObject}","page":"Vector Spaces","title":"Hecke.decompose","text":"function decompose(V::GVSObject)\n\nReturn a vector with the simple objects together with their multiplicities VXi.\n\n\n\n\n\n","category":"method"},{"location":"VectorSpaces/#Hecke.dual-Tuple{GVSObject}","page":"Vector Spaces","title":"Hecke.dual","text":"function dual(V::GVSObject)\n\nReturn the graded dual vector space of V.\n\n\n\n\n\n","category":"method"},{"location":"VectorSpaces/#Hecke.id-Tuple{VectorSpaceObject}","page":"Vector Spaces","title":"Hecke.id","text":"id(X::VectorSpaceObject{T}) where T\n\nReturn the identity on the vector space X.\n\n\n\n\n\n","category":"method"},{"location":"VectorSpaces/#Hecke.tensor_product-Tuple{GVSObject, GVSObject}","page":"Vector Spaces","title":"Hecke.tensor_product","text":"function tensor_product(V::GVSObject, W::GVSObject)\n\nReturn the tensor product VW.\n\n\n\n\n\n","category":"method"},{"location":"VectorSpaces/#Hecke.tensor_product-Tuple{VectorSpaceMorphism, VectorSpaceMorphism}","page":"Vector Spaces","title":"Hecke.tensor_product","text":"tensor_product(f::VectorSpaceMorphism, g::VectorSpaceMorphism)\n\nReturn the tensor product of vector space morphisms.\n\n\n\n\n\n","category":"method"},{"location":"VectorSpaces/#Hecke.tensor_product-Tuple{VectorSpaceObject, VectorSpaceObject}","page":"Vector Spaces","title":"Hecke.tensor_product","text":"tensor_product(X::VectorSpaceObject{T}, Y::VectorSpaceObject{T}) where {T,S1,S2}\n\nReturn the tensor product of vector spaces.\n\n\n\n\n\n","category":"method"},{"location":"VectorSpaces/#TensorCategories.Hom-Tuple{GVSObject, GVSObject}","page":"Vector Spaces","title":"TensorCategories.Hom","text":"function Hom(V::GVSObject, W::GVSObject)\n\nReturn the space of morphisms between graded vector spaces V and W.\n\n\n\n\n\n","category":"method"},{"location":"VectorSpaces/#TensorCategories.Hom-Tuple{VectorSpaceObject, VectorSpaceObject}","page":"Vector Spaces","title":"TensorCategories.Hom","text":"Hom(X::VectorSpaceObject, Y::VectorSpaceObject)\n\nReturn the Hom(XY`) as a vector space.\n\n\n\n\n\n","category":"method"},{"location":"VectorSpaces/#TensorCategories.associator-Tuple{GVSObject, GVSObject, GVSObject}","page":"Vector Spaces","title":"TensorCategories.associator","text":"function associator(U::GVSObject, V::GVSObject, W::GVSObject)\n\nreturn the associator isomorphism (UV)W  U(VW).\n\n\n\n\n\n","category":"method"},{"location":"VectorSpaces/#TensorCategories.associator-Tuple{VectorSpaceObject, VectorSpaceObject, VectorSpaceObject}","page":"Vector Spaces","title":"TensorCategories.associator","text":"associator(X::VectorSpaceObject, Y::VectorSpaceObject, Z::VectorSpaceObject)\n\nReturn the associator isomorphism a::(X⊗Y)⊗Z -> X⊗(Y⊗Z).\n\n\n\n\n\n","category":"method"},{"location":"VectorSpaces/#TensorCategories.dsum","page":"Vector Spaces","title":"TensorCategories.dsum","text":"dsum(X::VectorSpaceObject{T}, Y::VectorSpaceObject{T}, morphisms = false) where {T}\n\nDirect sum of vector spaces together with the embedding morphisms if morphisms = true.\n\n\n\n\n\n","category":"function"},{"location":"VectorSpaces/#TensorCategories.dsum-2","page":"Vector Spaces","title":"TensorCategories.dsum","text":"function dsum(V::GVSObject, W::GVSObject)\n\nReturn the direct sum object VW.\n\n\n\n\n\n","category":"function"},{"location":"VectorSpaces/#TensorCategories.dsum-Tuple{VectorSpaceMorphism, VectorSpaceMorphism}","page":"Vector Spaces","title":"TensorCategories.dsum","text":"dsum(f::VectorSpaceMorphism{T},g::VectorSpaceMorphism{T}) where T\n\nReturn the direct sum of morphisms of vector spaces.\n\n\n\n\n\n","category":"method"},{"location":"VectorSpaces/#TensorCategories.ev-Tuple{GVSObject}","page":"Vector Spaces","title":"TensorCategories.ev","text":"function ev(V::GVSObject)\n\nReturn the evaluation map V*V  𝟙.\n\n\n\n\n\n","category":"method"},{"location":"VectorSpaces/#TensorCategories.simples-Tuple{GradedVectorSpaces}","page":"Vector Spaces","title":"TensorCategories.simples","text":"function simples(C::GradedVectorSpaces)\n\nReturn a vector containing the simple objects of C.\n\n\n\n\n\n","category":"method"},{"location":"#TensorCategories.jl","page":"Home","title":"TensorCategories.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"TensorCategories is a package under development with the intention to provide a framework as well a examples for computations in the realm of categories.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"You need to have Julia installed. For reliable results Julia version at least 1.6 is required. To use TensorCategories do the following:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> import Pkg\njulia> Pkg.add(url = \"https://github.com/FabianMaeurer/TensorCategories.jl\")","category":"page"},{"location":"#Usage","page":"Home","title":"Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To use TensorCategories the structures from the OSCAR-System are required. Here a minimal usage Example.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using TensorCategories, Oscar;\n\n# Define an Ising Fusion category\nI = Ising()\n\n# Define the categorical center\nC = Center(Ising())\n\n# Compute the S-matrix of the center\nS = smatrix(C)","category":"page"},{"location":"#Acknowledgements","page":"Home","title":"Acknowledgements","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This project was started under supervision of Prof. Ulrich Thiel  (University of Kaiserslautern). This work is a contribution to the SFB-TRR 195 'Symbolic Tools in Mathematics and their Application' of the German Research Foundation (DFG).","category":"page"}]
}
